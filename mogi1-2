【第6草 : 問題12、15】

java.util Listインタフェースのofメソッドの特徴に関する問題です。
ofメソッドを使用すると、引致で渡された要素を持つコレクションを簡単に
作ることができます。引数に何も渡されなかった場合には、計素数0のコレ
クションを作ります。
ofメソッドは、変更不可能なコレクションを作るのが特徴です。ofメソッ
ドで作ったコレクションに対して変更を加えようとすると、 java.Iang.
UnsupportedOperationExceptionがスローされます。ofメソッドが作るコ
レクションは読み出し専用だと考えるとよいでしょう。
設商のコードでは、ofメソッドを使って空のコレクションを作り、その後add
メソッドで値を加えようとしています。そのため、このコードを実行しよう
とするとUnsupportedOperationExceptionがスローされます。addメソッドの
呼び出しそのものは文法上問違っていないため、コンバイルエラーは発生せ
ず、実行時に例外がスローされます。 以上のことから、選択野Dが正解です。

【第9草 : 問題1】


--- picture_0026.png ---
39. B                                       にP220 |
javaコマンドの起動バラメータに関する問題です。
javaコマンドの第1引数には実行したいクラスの完全修飾クラス名、第2引数
以降には起動パラメータを指定します。設問のコマンドであれば、次のよう
に分解して考えましよう。
[設問のコマンド]
javaA'AB'AB
1 ]
宛全修飾ケラス名 起動パラメータ
起動パラメータは、スペースで区切って複数の値を記述します。スペースを
信む文字列を1つの値として渡したい電合には、ダブルクォーテーション 「由
で括ります。そのため、設陸のコマンドでは、「A Bl 「Al 「B] という3つの
起動バラメータが渡さべれていることになります。
設問のコード4行目では、起動バパラメータをそのまま改行なしでコンソール
に表示しているため、「A Bl 「A] 「B] という3つを連結して「A BAB」 と表示
されます。以上のことから選択肢Bが正餅です。
【第1章 : 隊題8】
40. C                                       にP220 |
繰り返しの制御に関する問臣です。
設問のコードでは、4つの要素を持つString配列のインスタンスを生成し、そ
れを順番に繰り返し表示しようとしています。しかし、最初の文字「Al を
表示したあと、6行目のif文の条件式に合致しないためjf文の処理は行われず、
次の「end]」 を表示したあとにbreakで繰り返し処理を抜けてしまいます。そ
のため、コンソールには 「Al と「end] だけが表示されます。よって、選択
岐Cが正解です。
【第4章 : 問題14、151
474


--- picture_0027.png ---
インタフェースの継承と共変戻り値に関する問題です。
設問のインタフェース間の関係を図で表すと、次のようになります。
【設問のインタフェース間の関係】
*
1     8
5
L                                      第12意
Javaではクラスの多重継承は禁止されていますが、インタフェースの多重継
承は認められています (選択肢A)。
A、B、Cの3つのインタフェースで異なるのは、aメソッドの戻り値型です。ただ、
一見異なるように見えるものの、API ドキュメントを確認すると、java.lang
Iterableインタフェースはjava_utiLCollectionやjava.nio.file.Pathのスーパーイン
タフェースであることがわかります。
このように、メソッドをオーバーライドした際に戻り値型をサブクラスやサ
ブインタフェースにできる機能を 「共変戻り値] と呼びます。BとCでオーバー
ライドしたメソッドは、共変戻り値の機能が手くためコンパイルエラーが起
きることはありません (選択肢85)。 しかし、BとC両方のインタフェースを多
重継承したサブインタフェエースDでは、どちらの戻り値型を戻すメソッドを
引き継ぐのかが不明穴になるため、コンバイルエラーとなります。以上のこ
とから、選択肢Cが正解です。
 サブインタフェースでは、スーパーインタフェースのメソッドのオーバーラ
イド (再定義) が可能なだけであり、オーバーライドしなければいけないと
いうルールはありません (選択肢D)。
【第7草 : 問題10】


--- picture_0028.png ---
42. C                                       EEZEH
フィールドの選択に関する問題です。
油問のようにスーパークラスとサブプクラスに同じ名前のフィールドがあった
場合、そのインスタンスへの参照が何型で扱われているかで、 どちらのフィー
ルドが使われるかが決まります。
設問のコードでは、Bクラスのインスタンスへの参照をA型の義数で扱ってい
ます。そのため、Aに定義したフィールド>が使われます。よって、選択設C
が正解です。
なお、次のように変数のデータ型を5に変更するとコンバイルエラーとなり
ます。
団 多3%のデータ型をBに変更
pubtic class Mein (
pubtic static void main(String[] args) {
EE ェ mem B):
System.out.println(a.x):
)
)
これは、クラスに定美したフィールドドxがアクセス修朗子の付いていないデ
フォルトになっており、バパッケージ外からアクセスできないためです。
[生音 : 問題121
に                                       EZE
アクセス修導子に関する問軒です。
Javaには4つのアクセス修秘子がありますが、もっとも厳しいのがprivateで
す。privatcは、同じクラス内だけでしか使えないメンバに対して付けるアク
セス俸衝子です。privateなメンババには、控承関係にあるサブクラスからもア
クセスすることはできません。
設問のコードでは、Aクラスのprvateなメソッドとして定義されているsvalue
メソッドに、AクラスのサブクラスであるBからアクセスしています。 よって、
てのコードはコンバイルエラーとなります。以上のことから、 選択肢Dが正
解です。
[第5斉 : 問題26]
476


--- picture_0029.png ---
コンストラクタに関する耳です。
コンストラクタは、インスタンスの準供をするために欠かせません。 そのた
め、もしブログラマーが思示的にコンストラクタな定義しなくても、コンバ
イラによってデフォルトコンストラクタが自動的に追加されます。ただし、
設問のsampleクラスのようにコンストラクタが示的に定義されている場
合、デフォルトコンストラクタは追加されません。
コンバイラの役割は、コンストラクタが定革されていないときにデフォルト
コンストラクタな追加するだけではありません。クラスが夫承関係にある場
合、 スーパークラスのインスタンスから先に準備を始めなければいけません。
 そのため、サブクラスのコンストラクタの先頭行には、スーバパークラスのコ
ンストラクタを呼び出すコードが必要です。プログラマーが明示的にスー
バークラスのコンストラクタ呼び出しのコードを記六しなかった場合、コン
バイラは細なしのスーパークラスのコンストラクタ呼び出しのコードを自
動的に追加します。そのため、設凌のsubsampleクラスは、コンバイルする
と次のようなコードに変換されています。                              第12章
[iuper0が追加されたsubsampleクラス
public class SubSampte extends Sample{
int prioe
public SubSampte(int price) { // tineA
smper():
this.price = price:
)
public SubSample(String name, int num。 int price)
supertname。 num):
this(price): // tineB
}
}
スーパークラスであるsampleクラスには、 2つの引散を取るコンストラクタは
定馬されているものの、引数なしのコンストラクタは存在しません。また、
コンストラクタが明示的に定義されているため、前枯のようにデフォルトコ
ンストラクタが追加されることもありません。 そのため、lneAでコンパイル
エラーが発生します。
subsampleクラスはコンストラクタがオーバーロードされており、3つの引
を受け取るコンストラクタも定義されています。このコンストラクタでは、


--- picture_0030.png ---
明示的にスーパークラスのコンストラクタを呼び出していますが、次の行で
thisを使ってオーバーロードしたコンストラクタを呼び出しています。この
とき、前述のかようにスーパークラスのコンストラクタ呼び出しのコードが追
加されているため、このコンストラクタでは2回もスーパークラスのコンス
トラクタを呼び出すことになります。このような事態を防ぐため、スーパー
クラスのコンス トラクタを呼び出したあとは、オーバパーロードしたコンスト
ラクタを呼び出すことができないようになっています。よって、line Bでもコ
ンパイルエラーが発生します。
以上のことから、選択肢Eが正人です。
【第7章 : 問題20】
仙Overrideアノテーションに関する問題です。
@Overrideアノテーションは、そのメソッドが正しくオーバーライドしてい
るかどうかを確認するためのものです。 設問のコードでは、sampleインタ
フェースのtestメソッドをオーバーライドしているかどうかを確認します。
オーバーライドが成り立つ条件は以下のとおりです。
シグニチャ (メソッド名と引数) が同じであること
戻り値型が同じ型か、もしくはサブクラス型であること
アクセス修飾子が同じか、より緩くなること
選択肢^Aは、sampleインタフェースを実現しており、メソッドのシグニチャ
や戻り舘型も同じです。インタフェースに定義した抽象メソッドは、自動的
にpublicで修飾されるため、アクセス修節子も同じです。よって、 正しくオー
バーライドされています。
選択肢Bは、選択肢Aと同様にシグニチャ、戻り値型、アクセス修乱子は同じ
ですが、クラス宣言でimplementsを記述しておらず、Sampleインタフェース
を実現していません。つまり、Sampleインタフェースとは関係がないので、
オーバパーライドすべきメソッドではありません。よって、このコードはコン
パイルエラーとなるので正解です。
選択肢Cは、抽象メソッドとしてオーバーライドし直しています。インタ
フェースに定義された抽象メソッドを抽焦メソッドでオーバーライドし直す
ことに意味はありませんが、文法上は間違いではありません。また、前述の
オーバーライドの要件も満たしています。よって、正しくオーバパーライドさ
れています。
あき           選択肢Dは、抽象クラスの只象メソッドとしてオーバーライドしています。


--- picture_0031.png ---
インタフェースで定義された抽象メソッドは、必ずオーバーライドされて実
装が提供されなければいけません。 実装を提供するのは、抽旨クラスでも問
加はありません。このメソッド定義はオーバーライドの要件も満たしていま
す。よって、正しくオーバーライドされています。
[第7上 : 襲51
46. A                                            EZE3
LocalDateクラスに関する問題です。
java.time.LocalDateクラスは日付を表すクラスで、年月日などの情報を持ち
ます。
設問のコードでは、nowメソッドで現在の日付でqowフィールドを初期化し、
getNowメソッドで取り出して、コンソールに出力しています。LocalDateオ
 ブジェクトが持つ年月日の情報は、デフォルトでは 「年-月-日」 の書式で表
現されます。よって、 選択枝Aが正解です。
|
47. A                                            |・P426 |      第12章
java.ang.Mathクラスのnowメソッドに関する問題です。
powメソッドは、第1引数の値を第2引数の値で案乗した結果を戻します。 設
間の計算式を1行で表すと次のようになります。
a=bX(c(1+O"そテロオキ9"ー1)
n乗となっている箇所をMathクラスのpowメソッドに置き換えると次のよう
になります。
団 powメソッドで表した (1+o"
a=b・(c・Math.pow(1+c,加7 (Math.pow(1+c天-1))
以上のことから、選択肥Aが正解です。
【第9草 : 商頭1】
48. A
起動パラメータと後放インクリメントに関する問皿です。
javaコマンドの第1引数には実行するクラスの完全修偉クラス名、第2引数以
降には起動バラメータを指定します。設村のコマンドであればぼ、次のように
分けて考えるとよいでしょう。


--- picture_0032.png ---
[設問のコマンド】
JavaMamabe
1      1
完全作爺クラス名 起動パラメータ
よって、コンソールには 「al「b]「c| の順で表示されます (選択彼As
Mamは実行するプログラムの完全億師クラス名なので、コンソール(に表示さ
れることはありません (選択股C、D)。
また、後意インクリメントは、値のコピーを戻してから、 変数の値を大電し
ます。そのため、設問の繰り返し処理の中では、インクリメントによって温
える前の人が使われ、コンソールには1から順に表示されます (選択肌8)。
【化1章 : 問題6、 第3音 : 問題

49. A                                       EZEH
フィールドとローカル変数の有効団に関する届悪です。
フィールドとローカル変数が同じ変数名である場合、メソッド内ではthisを
使った明示的な指定がない限りローカル変数が優先されます。
設問のコードで呼び出されているsetAlメソッドは、1行に3つの代入注邊子
「=」を使った複巡なステートメントです。代入演算子は、右側の処理が終わっ
てから代入するため、setAllメソッドの名理は右側から考えます。まず、受け
取った引数を淫してsetDメソッドを実行します。このメソッドはdフィールド
に値を代入し、その値を戻します。よって、setDメソッドの実行が終わった
箕北でのsetllXソッドは、次のコードと同じ意味を持ちます。
ab・ this.c 10
次はthを使って明示的に指示された<フィールドに10を代入します。 その人、
bに代入することになりますが、setAIlXソッドで証言されているローカル変
数は引数の<だけです。よって、この到数b3bフィールドだとわかります。
ョ= = 10
フィールドに10を代入すれば、 同じ要領でaフィールドにも値を代入します。
a = 107

480


--- picture_0033.png ---
以上のことから、sampleクラスのインスタンスsのすべてのフィールドには

10が代入されていることになります。 最後にprinttnメゾッドは内部でインス

タンスのtostringメソッドを呼び出すため、コンソールには選択肢Aのように

表示されます。
第7計器181
50. D                                       EEZE
do-while文に関する問題です。

do-while文の特徴は、繰り返し処理をするかどうかの判定を、繰り返し処理

後に行う点です。 そのため、必ず1回は処理が実行されます。

設両のコードでは、変数umを宣言し、 0で初期化しています。そのあと、do

ブロック内でnumをインクリメントしています。if文ではnumの慎が1であれ

ば、continueによってその後のコンソールへの出力がスキップされ、条件

式に飛びます。 条件式ではnumの億は1よりも小さくないと判定されるため、

do-while文を抜けます。一度もコンソールへの表示が行われないため、選訳

段Dが正解となります。

[4 :半可21 第12電
51. A、C                                    EEE

例外処理の構文に関する問題です。

多外処理の構文については、以下のポイントを押さえておきましょう。

・try-catch-finallyもしくはtry-finallyの順番になる (選択肢A)

・ Tyrcatch-finallyの順に記述するとき、finalyプロックは省略可能 (選択睦5け

・ 1つの例外処理では、catchプロックは複数記述できるが、tryプロックと
finalyプロックは1つしが記述できない

・ catchブロックは例外の種類によって分ける
catchプロックは上から順番に処理されるので、ポリモーフィズムによって
地理できるものが前にあると、後ろのcatchプロックは到達不能になる

finalyブロックは、次のいずれかの場所に記述します。

・ catchブロックに例外処理を記述する場合は、catcrhプロックの後ろ
throwsで例外を呼び出し元のメソッドにスローするなど、catchブロック
による合外各理を記述する必要がない場合は、t9プロックの後ろ

finalyブロックは、例外処理の最後に実行されます。これはtry-with-

resourcesであつても同様で、最後にfnalyブロックが実行されます (選択肢B)。

catchブロックは発生する可能性のある例外の種類ごとに記述できます。複数


--- picture_0034.png ---
の例外が発生する場合は、calchブロックを複数記述することができます (選
択肢C)。ただし、 一般的な型 (スーパークラス) から特定の型 (サブクラス)
の順にcatchブロックを並べることはできません。例外の型をポリモーフィズ
ムによって沢化して扱うと、サブクラス型の例外はスーパークラス型のcatch
ブロックでキャッチできてしまうため、サブクラス型をキャッチするための
catchプロックが到達不能なコードになってしまい、コンバイルエラーとなり
ます (選択股D)。

【第10章 : 問題2、3、8】
java.uti.Arraysクラスに関する問題です。
Arraysクラスのmismatchメソッドは、引数で渡された2つの配列の要素のう
ち、先頭から順番に比較して一致しない要素の添字 (インデックス) を戻し
ます。
また、compareメソッドは、2つの配列を辞書順に並べたときの並び順を比較
します。compareメゾッドは、引数で受け取った2つの配列が等しい場合は0
を戻します。もし、第1引致が第2引数よりも辞書順で先なら負の値を、逆に
第2引数のほうが先なら正の値を戻します。
設問のコードでresult1に代入するのは、mismatchメソッドの結果です。 引数
で渡されている配列の要素のうち、一致しないのは3番目の要素です。 添字
は0番から始まるので、 3番目の要素の添字は2となります。よって、result1に
は2が代入されます。
result2に代入するのは、compareメソッドの結果です。2つの配列のうち、異
なるのは3番目の要素です。 3番目の要素の値は第1引数として渡したarray1の
ほうが小さいため、第13 |数のほうが先となります。そのため、compareメソッ
ドは鋼の値を戻します。
コンソールに表示される1番目の数字が2で、 2番目が負の数合なのは、選択設
てです。

【第9草 : 問題15、16】
Mathクラスのメソッドに関する問題です。
java.lang.Mathクラスは、基本的な数値計算のためのクラスです。 設問のコー
ドで使われているroundメソッドは、小数点以下を丸めて整数にするための
メソッドです。
roundメゾッドは、引数にdouble型もしくはfloat型のいずれかを受け取り、淫
動小数点数を含お値を四捨五入して整数にします。「roundは、淫動小数点数

2             の値を受け取るメソッド」 と覚えておきましょう。


--- picture_0035.png ---
較 oundaメソッド

System.outprinttnath.round(3.4)): // 3と表示される

System.aut.printin(Math.round(3.5)):// 4と表示される

roundメソッドは、小数点以下な四拾五入るためのメソッドであるため、

丸める処理をする対象となる刷以外を必要としません。 そのため、受け取る

引数は1つだけで、選択農CPOのように3孤を2つ呈け取ることはありません。

よって、これらの避択反は訓りです。

避択芝@では、roundメソッドの千果を、floa(にキャストした100で割り、そ

の結果な変数に代入していますず。そこで、まずはroundメソッドの中での江

算を先に実行します。roundメソッド内で行われているのは、floatにキャス

トした>をyで割り、さらに100を掛けるという洒香です。

具休的な値を入れると「5.0/2* 100」 となるので、 250.0という結果になり、

このroundメソッドの結果を100.0で割ると2.5になります。以上のことから、

信択及Aが正解です。

なお、算条算子よりもキャストのはうが大和朗が高いので、キャストし終 第12章

わったあとに算術演算が行われます。

選択肢B8では、floatにキャストしたxをyで割りb、さらに100を拍けているので、

250.0という結果になるところまでは選択上4と回じです。しかし、この億を

roundメソッドに渡しているので、小数点以下が丸められて250という値にな

ります。そして、この値をさらに100で割っています。どちらもint同寺の

算であるため、小数以下が切り捨てられて (2.5となるところが)2という千

 果になります。以上のことから、羽抽8は調りです。

[因3理 : 間二3、第9 : 居呈1

54. Dp                                       EEZETI

インタフェースの実男に関する問題です。

インタフェースの宮言には、interfaceに穂けてインタフェース名を記述しま

す。インタフェースには、そのインタフェースを実現したクラスが持つべき

メソッドを定義します。

設問のsampleインタフェースでは、testXソッドを定義しています。 このメ

ソッドは搭楽メソッドです。 中カッコ 「()」 なし、セミコロン [:」 で、メソッ

ドの宣言だけをしているため、文法上の放りはありません。よって、 選択肢

Aは誤りです。

samplelmplクラスは、sampleインタフェースを実現したクラスです。このク


--- picture_0036.png ---
ラスは抽旬クラスではなく只請クラスであるため、インタフェースに定義さ
れている抽県メソッドをオーバーライドしなければいけません。5amplelml
クラスは、 sampleインタフェースに定義されているtestXソッドを正しくオー
バーライドしているため、コンバパイルエラーが発生するとした選択時は誤
りです。
subsamplelmplクラスは、 Samplelmplクラスを継承したサブクラスです。
sampleインタフェースで定開した朝メソッドは、スーパークラスである
samplelmplがオーバーライドしているため、ことのクラスではsampleインタ
フェースに証革されているtestメソッドを実装する必要はありません。また、
tws:Xソッドのオーパーロードにも文法上の談りはありません。よって、選
択腕じも謎ひです。
以上のことから、これらのインタフェースやクラスはコンバイルエラーには
ならず、正常に実行されます。よって、選択有DPが正解です。
[革7音 :半題3

55. A、B、D、F                       | > P431 |
変数の型と初化する値に関する問題です。
選択肢Aは、 2次元下の変数に、 2次元目の琵釣のインスタンスへの参照を
代入しています。よって、正解です。
選択肢6ま、char弄をshon型にキャストして代入しています。 char弄で表され
る文字は、文字番号に相当する数人で管理されています。 そのため、キャス
ト式を記述すればchar型をshor可の変塊に代入することや、その逆も可能で
す。 よって、 正解です。
選択肢は、byto弄の数c1を宣言初期化し、その後ha型の変数に代入し
ています。 前久のとおり、文字と至全は吾換性がありますが、キャスト式を
記述しなければいけません。よって、調りです。
選択肢Dは、比較活路子の結末をboolean型の計数dに代入しています。 比較
演算子の結果はboolean型の値なので、代入は成功します。よって、正解です。
避所時は、fioatの変数に浮動小数代入しています。浮生小数リ
テラルは、デフォルトではdouble政として解択されます。もし、float型のリ
テラルであることを明示したい場合には「1.99f] のように{を付けなければ
いけません。よって、 誤りです。

484


--- picture_0037.png ---
選択肢Fは、区切り記号としてのアンダースコア「_] を使って、数値リテラ
ルをint型の変数に代入しています。 数値リテラルは暗熱的にint型として解息
されるため、int型の値をint型の変数に代入していることになります。よって、
正解です。
選択肢Gは、シングルクォーテーション「」 で括った文字はchar型として扱
われます。 String型の変数にchar型のリテラルを代入しようとしていますが、
string型とchar型に互換性はありません。よって、誤りです。
【第2草 : 問題3、第5草 : 商頭7】
2次元配列と二重ループに関する問題です。
2次元配列は、配列を集めた配列です。
設問のコードでは、二重ループを使いながら、 2次元目の配列の要素を出力し
ています。 一重ループが出悪されたときは、まず「内側のループが何をして
いるのか」 を理解するところから始めましょう。 設問のコード8一13行目を
次のように解収すると、二重ループではなく一重ループとして考えられるの    第12章
で、複雑な処理でも簡単になります。
団 内側のfor文を説明に置き換えて考える
for int i=0: 1くarray.tength: itt) [
it =
// 2次有力する =ニニ)。 て内本のループの生
1
解答のポイントは、 2次元目の配列の要素数がいくつあるかです。 設問のコー
ドでは、 2つの要素を持った配列 (4行目)、要素が1つだけの配列 (5行目)、 4
つの要素を持った配列 (6行日) を作り、 それを1つの妃列でまとめています。
この要素数に合致するのは、2つ、1つ、4つの順に表示されている選択肢Bです。
選択肢Aは、2つ、2つ、3つの順に表示されています。選択肢cは、2つ、2つ、2つ、
1つと2次元目の配列が4つあることになっています。 選択股Dは、3つ、4つと2
次元目の配列が2つしかありません。よって、これらの選択肢は誤りです。
[< : 問量9、第5 8】


--- picture_0038.png ---
57. C                                       EEZEEi
拉数のcatdhブロックのある例外巡理に関する阿題です。
設問のコードでは、 複数のcatchブロックを記述して、スローされる例外の
種類に広じて守なる例外処理ができるようになっています。経承関係にある
複数の例外クラスをcatchブロックで指定する場合 必ずサブクラスのcatch
ブロックを先に記述しなければなりません。
設陸のコードの57行帳にはExceptonクラスが指定されたcatchブロックが記
送されているため、すべてのExceptionクラスのサブクラスがここでキャッチ
でれます。そのため、ExceptionクラスのサブクラスであるRuntimeExcepton
をキャッチするcatchブロックに名理が到達することはありません。このよ
うに到達可能なコードを記述するとコンパイルエラーが発生します。した
がって、 選択肛が正解です。
[季10車:還31
58. A                                       EZEz3
インクリメントを後天したときの加のタイミングに関する癌是です。
後言インクリメントの慢合、式を実行し終わつたあとに、加筐された仁で補
数の値が上者きされます。 そのため、設問のコードの科件式は、加算される
前の仁で比較され、条件式の評価が綴わったタイミングで変数の仁が変更さ
れます。よって、コンソールには算後の値である10が表示されます。以上
のことから、 選択股Aが正解です。
3 :計41
59. A                                       EEZEZ3
狼全と文字の宮村に関する問題です。
+演修子を使って数悦と文字別を達生すると、数他が文字別に変換されます。
設問のコードのように+演算子で連結している式は、左から順に処理されま
す。 まず [a + b] が刀理され、次のようなステートメントになります。
6+ "=人aょ5 ="+a+bD
次は、6という数人と文字別の連結であるため、6は数字 (Sting型) に委換さ
れて文深別として回結されます。
"の"・ "=(a+D) = "atb
486


--- picture_0039.png ---
この文字別較を実行すると、次のような結果になります。
"6 = G+ 1a+b
次に実行されるのが、「"6 = ぉ + D) ="+ al という文字列と数値の連結です。
これも同じように数値が数字に変換されて、次のようなステートメントにな
ります。
6 = GrDょrb
最後も、数値が数字に趣き換わって文字列として連結され、結果は次のよう
な文字列となります。
6 = (G+D) -427
= 。                                         第12章
以上のことから、選択皮Aが正症です。
[第2草 : 問題18】
60. C                                       EZEH
型変換に関する半題です。
設音のコードでは、shon型の秋数s1とInteger型の変数:2を用意し、それぞれ
10と20の値を代入しています (3一4行日)。加数リテラルはデフォルトでは
in中として解孔されますが、short較の範団 (-32768一32767) であれば自重
的に型変換されて代入されます。 また、Integer型の変数にint型の価を代入す
るときには、オートボクシングによって自動的にIntegerのインスタンスが生
成されます。
次に、5行日でs1とs2を加算していますが、まずs1がlong型へのキャスト式に
よってshor'型からlong型に変洪されます。その後、Iong型の値と>2が加算さ
れるタイミングでs2がアンポクシングされてint型に変換され、long型とint弄
の加算になります。このように大きな外全型と小さな数慎重の演算では、小
さな型が大きな型に変換されるため、この演算はlong弄同士の加筐として扱
われます。 よって、5行自の「(long) s1 + s2Z」の結果はlong型になります。 そ
の演算結果を受け取る変数はLong型でちあるため、long型の演算結果がオー
トボクシングされてlong型に変換されます。 以上のことから、5行目でコンパ
イルエラーが発生することも、実行時に例外がスローされることもありませ
ん。よって、 選択肢BとDは誤りです。


--- picture_0040.png ---
6行征では、s3とs2を加算し、その結果をString天にキャストしようとしてい
ます。s3はLong型、s2はInteger型で互換性はありませんが、アンボクシング
することでlong型とint型の加算になります。前述のとおり、このように大き
な数値型と小さな数値型の演算では、小さな型が大きな型に変換されてlong
型同士の加算として扱われます。そのため、加算は問題なく実行できます。
しかし、その後のlong型からstring型へのキャストができないため、互換性が
ないとしてコンパイルエラーが発生します。以上のことから、選択肢Cが正
劉です。
【第3章 : 問題3、第7草 : 問題16】

文字列のコンスタントプールに関する問題です。
 ブログラム内では文字列が頻繁に使われます。同じ文字列のインスタンスを
作るためにメモリの確保と解放を繰り返すのは、メモリを消旨するだけでな
く、パフォーマンスにも影響を及ぼします。そのため、Javaでは文字列を使
い回す仕組みとしてコンスタントプールが用意されています。 文字列の使い
回しについてのポイントは次のとおりです。

リテラルとして記述した文字列は基本的に使い回される

newを使ってStringのインスタンス生成を明示的に記述した場合には、新

しいstring型オブジェクトが生成される

javalang.Stringクラスのinternメソッドは、すでにメモリ上にあるString型

オブジェクトへの参照を戻す
設問のコードでは、 3つのString弄変数を用意しています。1つづ目のs1には、実
行時に生成したstring型インスタンスの参照を代入しています (3行目)。 2
つ目のs2には、文字列のリテラルを代入しています (4行目)。リテラルは
コンバイル時に定数として扱われます。よって、生成されるタイミングが異
なる1つ日と2つ日のstringは同じインスタンスではありません。そのため、
「s1 = -s2」の結果はfalseとなります。
3つ目のs3には、2つ目のstringのインスタンスへの参照をintemメソッドで取
り出して代入しています (5行目)。そのため、2つ目と3つ目は同じインスタ
ンスへの参照を待つことになります。よって、「s2==s3」 の結果はtrueとな
ります。
2つ目と3つ目が同じ参照先を持っているため、 1つ目と2つ目が異なれば、1つ
目と3つ目も異なることになります。よって、「s1- -s3」の結果はfalseとな
ります。
=ー演算子は、インスタンスの参照が同じ (同一) かどうかを判定するとい
うことにも注意しましょう。

488


--- picture_0041.png ---
以上のことから、コンソールには 「lske, tue fabel と表示されます。よって、
選択上Aが正能です。
[第2草 : 山是9、第3 : 問加8、14】
2次元目の配列と二宣ループに関する問題です。
二革ループは、 内別のループを和単な説明に置き換えるとわかりやすくなり
ます。 設問のコードの一重ループの内側のループでは、 配列から文字を取り
出し、スペースを入れずに並べて出力しています。内側のfor文をこの説明に
値き換えると次のようになります。これで二生ループが科単な一重のループ
に土き換わります。
団 内側のfor文を説明に置き換えて考える
pubtic ctass Mein {
pubtic ststic void sain(Stringl] ares) (
cherllll arraws = ta dH Dr ed Ce。 お
for (charll array : arrays)【                       第12章
// 可から文字を取り出し、 スペースを入れすに\べて出力
System.out.print('         人 内出のループの衝理
}
H
}
このループでは、2次元配列から1つずつ配列を取り出して、繰り返し始二を
実行します。 変数arraysで参照する配列には、配列が3つ入っているため、紹
り返し処理が実行されるのは3回です。
1回目は 「s」「d」という文字を持った生列が取り出されます。謀り返し処理
では、配烈から文字を取り出し、スペースを入れずに並べて出力するので、
コンソールには 「ad」 と表示されます。 その後、スペースを出力します。
2回目は「b」 lel という文字を持った配列が取り出されます。1回日と同様
に出力されるので、先ほどの出力結果と合わせて [ad be 」 とコンソールに
表示されます。
3回目は 「cl 人 という文字を持った配列が取り出されます。 同様に、コンソー
ルには先ほどの出力結果と合わせて 「ad be cf 」 と表示されます。 以上のこ
とから、 選択誌Aが正館です。
[第<章 : 了題9、第5草 :敵是8】


--- picture_0042.png ---
ローカル変数の初因化に関する問題です。
初期化されていないローカル変数を参照しようとすると、コンバイルエラー
になります。設問のコードでは、5行目のif文の条件式はrueと判定されるため
6行昌に移りますが、変数xは初期化されることなく、11行目でコンソールへ
の表示に変数xが使わねれます。そのため、このコードはコンバイルエラーとな
ります。よって、和選択肢Cが正解です。
【第6章 : 周題9】
mainメゾッドに関する問題です。
設問のコードでは、mainメソッドがオーバーロードされて3つ定装されてい
ます。3つとも引数の型が異なるため、オーバーロードの条件は満たしてい
 ます。よって、コンバパイルエラーが発生しないため、選択肢Dは語りです。
Javaプログラムのエントリーポイントとなるmainメゾッドは、その定義が決
まっています。変更できるのは引数の変数名だけで、その他は変更できませ
ん。エントリーポイントになるのは、string配列型の引数を受け取るものだ
けです。よって、 設問のコードを実行すると「c| と表示されます。以上の
ことから、温択肢てが正解です。
【第1章 : 問題5】
 コンストラクタチェインに関する問題です。
 サブクラスをコンパイルすると、サブクラスのコンストラクタには、次のよ
うにスーバークラスのコンストラクタを呼び出すsuper():が所加されます。
 サブクラスのコンストラクタにsuper0:が追加される
public class B extends Al
Bt
this(4):
system.out.print(3り:
}
Btint 5) {
super():        スーパークラスのコンストラクタび出し
System.out.print(b):
}
}
490


--- picture_0043.png ---
そのため、Bクラスのインスタンスを生成すると、次の順番でコンストラク
タが負理されます。
①Bクラスの引数なしのコンストラクタを呼び出し、tnisを使ってオーバー
ロードされたコンストラクタを呼び出す
⑧クラスのmt呈の引を受け取るコンストラクタを呼び出し、superを使っ
てAクラスの3節なしのコンストラクタを呼び出す
⑧Aクラスの引教なしのコンストラクタを呼び出し、thisを使ってオーバー
ロードされたコンストラクタを呼び出す
④⑧Aクラスのint起の細を受け取るコンストラクタで翌け取った値 「2] を表
示し、Aクラスの引数なしのコンストラクタに戻る
⑤Aクラスの引数なしのコンストラクタで値「1」を表示する
⑮Bクラスのint型を受け取るコンストラクタで、引数で受け取った慎 「4] を
表示する
⑦Bクラスの引数なしのコンストラクタで、慎「3] を表示する
以上のことから、 選択岐Aが正合です。
第7 : 問題0 第12章
66. D                                            EZEE
メソッド参照に関する問題です。
再利用しない和な処理を記述するのであれば、ラムダ式を使います。 関委
型インタフェースの実装に、ラムダ式ではなく奴存のメソッドを流月するの
であればメソッド参照を使います。
メソッド参照の構文は以下のとおりです。
クラスメソッドの参照
クラス名: :メソッド名
インスタンスメソッドの昭
インスタンス名: :メソッド名
クラスメソッドとインスタンスメソッドの違いはありますが、どちらもメ
ソッド名までしかが記述しません。カッコ 「()」を記述すると「メソッド呼び
出し と解択されるので注意しましょう。 以上のことから、 選択股Dが正解
です。
選択肢Aはインスタンスを生成して、そのインスタンスのメソッドな参照し
ようとしています。もし、Sampleクラスのprintメソッドがstaticで億館されて


--- picture_0044.png ---
いなければ正解ですが、設問のコードのsampleクラスのprintメソッドはクラ
スメソッドであるため、この構文では参照することはできません。よって、
誤りです。
メソッド参照の構文では「: :」 とコロンを2つ並べます。ドット「.」やコロ
ン1つでは参照することはできません。よって、選択枝BとCは誤りです。
【第9章 : 問題18】
Javaの開発環境であるJDKに関する題です。
」avaで作られたアプリケーションは、「write once, run anywhere] のポリシー
のもと、多くのブラットフォームで同じように動作します。しかし、アプ
リケーションを作るための開発環境であるJDK (Java Development Kit) は、
Windowsで開発するのであればWindows用、macOsで開発するのであれば
macOS用という具合に、各オペレーティングシステム用のものが用意されて
います (選択肢A、 選択肢B)。
JDKには、Jawaの実行環境であるJRE (Java Runtime Envircnment) も含まれて
いるので、JREを個別にセットアップする必要はありません (選択肢C)。なお、
Java SE 11では、パブリックJRE単体のダウンロードは提供されていません。
実際のアブリケーション開発には、IDE (統合開発環境) を利用します。 Java
のIpEとしてよく知られているのは、Eclipse、Intell、NetBeansなどです。こご
れらはjDkとは別に用意されており、IDEをインス トールしてもJDKが同時に
インストールされるわけではありません (選択肢D)。
フィールドを示すthisと可変長引数に関する問題です。
string配列型のフィールドを初期化するためのコンストラクタを定義するに
は、string配列型の引数を受け取らなくてはいけません。可変長引数はコン
バイル時に配列に置き換わるため、string型の可変長引数は、String配列型の
引数であると考えましょう。
設問の選択設のうち、String配列型もしくはString型の可変長引数を受け取ら
ないコンストラクタは選択肢Cとfです。 選択肢Cはstring型を受け取っていま
すが、string型とstring配列型に互換性はありません。 選択肢Fは、Object配列
型の引数を受け取っていますが、Object配別型への参照をstring配列型の変数
に代入するにはキャスト式が必要です。よって、誤りです。
設問のコードではフィールド名がarrayとなっていますが、各選択肢の引数名
も同じarrayです。このようにフィールドと同名のローカル変数が宣言された
92         場合、明示的にthisを使ってフィールドであることを宣言しなければ、ロー


--- picture_0045.png ---
カル変数が大先されます。 選択設8やDはthsを使っていないため、ローカル
変数arrayにローカル変数arryの値を再代入しています。 結果としてフィール
ドには困も代入されず、nulのままです。よって、 誤りです。
選択彼AはString配列型、信所隊gはString型の可変友引用を受け取り、rnisを
使って明示的にフィールドに対して、受け取った引苑の参照を代入していま
す。 よって、 正解です。
【第7間 : 問題18】
69. D                                       EZzrI
多外の衝類についての問題です。
Javaの例外には、 検査例外と非検査例外、エラーの3つがあります。 検胡合外
と電栓李合條の違いは、torcatchを強制するか大かです。 エラーは、ブログ
ラムでは対処できないようなトラブルが発生したことな意味します。
設問のコードでは、ArrsyListのインスタンスを生成して、「helo] という文字
列を追加しています。 問題は、while六の条件がtrueとなっているため、 無限 第12章
ループになる点です。ArrayListのインスタンスには無眼に「hello] という文
字列が追加されるため、いずれはメモリを使い切ってしまい、やがて次のよ
うなエラーが発生することになります。
Exception in thread "matn' ava.1ang.0nt0fMemoryError: ava heap space
エラーは前述のとおり、検査例外人や非検衣例外とは異なるものです。 そのた
め、EyceptontやRuntimeExceptionをキャッチするcatchブロックではキャッチ
することはできません。以上のことから、 実行時に例外がスローされる」 と
した選択肢が正解です。
【第10草 : 問題12】
70. C                                       EZrrI
モジュール内のプログラムを実行するためのjaraコマンドのオプションに閲
する隅丁です。
モジュール内のプログラムを実行するには、javaコマンドの-module-path
オプションでモジュールのルートディレクトリな指定し、mオプションで「実
行したいモジュール名/完全修飾クラス名」を指定します。よって、 選択肢
が正解です。
Java --module-path モジュールのルートディレクトリ -n 実行したいモ
ジュールのクラス


--- picture_0046.png ---
-てasspathは、クラスバスを指定するオプションです。
[策11剤 : 隊題1
71. Dp                                       EZ
2次元記別と二重ループに関する埋吾です。
設問の配列は、次のような構造を持つ2次元配列です。
届問の配列の構造
た
この配釣のすべての要素をコンソールに出力するには、次のコードのような
ループが必要です。
 配列の要素を出力する撤張for文
for inti=0: 1<2: it
for Gtjs0:1く< jj9【(
system.out.printtarrayili]):
)
)
てのような一重ループが出還された場合は、内購のループが加をするコード
なのかを見定めます。上記のコードでは、内側のループは2次元目の要素を
コンソールに出力しています。 そこで次のように特申化すると、 複雑に見え
る二生ループであっても理解しやすくなります。
団 重ループを簡路化した形
for Gti・0 1<2 ir)(
// 2次上の東を表示する(内側のループ)
)
本設問で重要なポイントは、 2つの可素を持つ配列が2つある2次元配列を扱っ
ているため、1つ目の配列の0番目と1番目、2つ目の配列の0秋目1番目を順に
表示しなければいけない点です。しかし、肖設Aは初期便を0からではなく
494


--- picture_0047.png ---
1から始めています。そのため、 2つ目の配多の1番目の要球しか出力されませ

ん。 以上のことから、 選択設Aは斉りです。

また、上記の正しいコード例では、変到と)の値、またそのときの結果の話係

は次の表のとおりとなります。

| 0 | 9 |が表示される|

|-0 | 1 |の表示される

| ! | 0 |<が表示される

| 」 |表示ehる

選択邊8は、 初期全は外側のループも内側のループも0から始まっていますが、

内拓の条件式が [) < ] となっているため、次のように条件を表にすると、

すべての亜素が表示されるわけではないてとがわかります。

| 0 | 0 |条件に一致しないのでループの内側を抜ける                 第12章

|s | 」 [setgo |

| ! | 0 |<が表示される

| 1 | 1 | 条件に一致しないのでループの内側を抜ける

また、鉱張for文では2次元配列の1次元日だけを取り出して操り返すことはで

さません。よって、 人択邊Cは読りです。

人択肢Dは更新文がないため、一見すると倍加いに思えますが、 更新文は必

須ではなく人省略可能です。朋択記pのコードではループ中|にインクリメント

しているため、 変数(と)は両方とも1回どとに1ずつ増えており、更新文がな

くても正しく動作します。 以上のことから、 選択肢Dが正解です。

[第<間 : 問題9、第5芋 : 習8】

72. B                                       EEZ

 stringBuilderクラスのメソッドに関する問題です。

javaJang.StringBuilderクラスのreplaceメソッドは、 第1 当と第2引当で沸

定した和民の文字列を、生3細の文字にざ換えます。

indexOfメソッドは、引数で渡された文字列の位置を表すインデックスを戻

します。 次のように文字別に番号を振るとわかりやすいでしょう。


--- picture_0048.png ---
【設問の文字列のイメージ】
回回回
op 1 sz s
吾選択設では、index0fメゾソッドが戻したインデックスをreplaceメゾソッドの第
1引数、第2引数に渡し、廊換する範囲を指定しています。
「ABCD] という文字列を「AXCD」 に直き換えるので、BをXに起き換えれぼ
よいことになります。
【設問の文字列のイメージ】
%
IA1BiICIDI
0 1 2 3 4
きえ3
上記の図からわかるとおり、開始位置は1、終了位置は2です。そのため、
index0fメソッドが8とCの手前までを抜き出しているのが正しいコードです。
よって、選択肢Bが正解です。
【第2章 : 問題21、22】
73. B                                   EEZZE
for文の条件指定についても問証です。
「135」 と表示するには、配列の0番目から2番、4番という順番に表示すればよ
いことになります。しかし、和選択肢CとDの変数*の初牙化では1番是から始め
てしまっています。よって、選択肢CとDは誤りです。
選択肢Aでは、変数(の値は0から始まって4まで品番に1つずつ増えていきま
す。そこで、配列の0番目の要素から始め、1つおきに表示するには、更新文
で1を加算するのではなく、 2を加算します。以上のことから、選択肢Bが正解
です。
【第4章 : 半題4】
74. Dp                                   EEZZZ3
配列に関する問題です。
オプジェクト型の配列のインスタンスを生成しても、配列で扱いたい要素の
インスタンスが生成されるわけではありません。あくまで配列のインスタン
スが生成されるだけで、要素の中身は空、つまりnullです。
496


--- picture_0049.png ---
設天のコードでは、2つの可乏を持つString本列型のインスタンスを生成して
います。ここで作られたのは、2つのstringを扱うことができる正別のインス
タンスであって、string型インスタンスが作成されたわけではないことに注
意しましょう。 そのため、 配列の要素はnulのままです。
拉張for六で、配列の要素を取り出していますが、 変数*にはnulが入っていま
す。 そのため、次の行でconcauXソッドを呼んだタイミングでNullPointer
Exceptionがスローされます。以上のことから、記択Dが正です。
【第5章 : 問題5、第10草 : 問題16】

rmodule-nfoJjveの設定に関する問題です。
モジュール設定ファイルであるmodule-info.javaには、依存するモジュール
や公開するパッケージを定義します。
依存するモジュールはrequiresで、公族するバッケージはexportsで宣言しま
す。 よって、洲択有Bが正解です。
選択肥は、com sampleモジュールに依存し、bリバッケージを公開するという 第12章
意味になります。 選択肢CやDのimportはパッケージのインボート宣言に使う
もので、モジュール定養ファイルには使いません。

【第11斉 : 問題3】
オーバーロードに関する財政です。
宰数のメソッドがオーバーロードされているとき、JVMは呼び出し元から渡
された引数の数や型、順矯で呼び出すメソッドを決定します。
設病のコードでは、起動パラメータな受け取るためのstring列型への参照
を減しています。Strng配列型は、ポリモーフィズムを使えばObject列型と
して扱うことも、またのObject型として扱うこともできます。
しかし、ポリモーフィズムを合って対処するのは、一致する型がなかったと
きです。 溢された引政と一致する型の引数を受け取るメソッドがある場合は、
そのメソッドを実行します。設問のコードにはstring配列型を受け取るtestメ
ソッドが実行され、コンソールには [Bl が表示されます。以上のことから、
選択肢Bが正解です。
なお、Stnino配列型を受け取るメソッドをコメントアウトしてこのブログラ
ムを実行すると、Object本列型を受け取るメソッドが呼び出されます。 複数
のオーバーロードされたメソッドで、どちらの引数の型でも処理可能な場合
には、より具体的な引を受け取るものを選択します。

【第6章 : 問題17】


--- picture_0050.png ---
キャストと弄計換に関する同題です。
スーパークラス型として扱つている参照を、サブクラス弄の変数に代入する
ことはできません。しかし、スーパークラス型として扱っている参照が、サ
ブクラス型と互滴性があることがわかっている場合、キャスト式を記述すれ
ばコンパイルはできます。
設問のコードでは、mamメソッドで2つのsubsampleのインスタンスを生成し、
それらの参照のうち1つをsubSample型の変数に、もう1つをSample型の変激に
代入しています。この交点で、2つ目の参頭はスーバークラスであるsample弄
として扱っているので、実際のインスタンスの型とは関係なくsampleへの参照
と見なされます。
IMainクラスの5行晶で、スーパークラスでおるsampleの参照をサブクラスで
あるSubsample弄の座数に代入しようとしていますが、キャスト式を記述し
ていません。そのため、 このコードはコンバイルエラーとなります。 よって、
選択Eが正解です。

[生7間 :半題161
オーバーライド時のアクセス偽盆子に関する問題です。
メソッドをオーバーライドするとき、アクセス修秋子は司じか杉くしなけれ
ばいけません。 スーパークラスに定義されたメソッドよりも成しいアクセス
修衝子で修作すると、コンバイルエラーになります。
設問のAクラスに定義されているrestXメソッドはprotectedで修飾されてい
ます。 Javaのアクセス俸記子は、public、protected、デフォルト (ない)、
priyateの順に赤しくなります。そのため、Aクラスを座承した8クラスでtest
メソッドをオーバーライドするときには、publicかprotectedで柳航しなけれ
ばいけません。よって、 選択肢AとDが正角です。

【第7章 半題11】
モジュールシステムに関する半量です。
モジュール内の公外するパッケージは、module-info.javaのexportsで宣言
します。一時83に公開するバッケージを追加したい場合には、javaコマンド
の--add-exportsオプションを使うことができます。ただし、本来はmodule-
infojavaに記述すべきことであるため、推表されません (選択A)。

2           モジュールシステムが導入されてからも、奴存のAPIが非推奨になったわけで


--- picture_0051.png ---
はありません (選択肢C)。Javaの辺準クラスライブラリに含まれていた肢本

的なAPは、java.baseモジュールに含まれています (選択肢5)。

モジュールシステムに対応したJDKを使用して、モジュール化されていない

アプリケーション (モジュールシステムが必入される以前と同じ状穏のアプ

リケーション) を実行する場合、そのアプリケーションは陸的に無名モ

ジュールに属していると見なされます (選択肢D)。なお、無名モジュールは

すべてのモジュールを読み込み、すべてのバッケージな公開します。

【第11章 : 問還5、7】

80. A                                       EZTE

配列のlengthに関する問題です。

設間のコードでは、stingの2次元配列のインスタンスな作っています。この2

次元記列は、1次元月(に2つの要素を抜うことができ、2次元昌には2つの聖素を

持つ配列と5つの要素を持つ配列のインスタンスへの参照が格約されています。
