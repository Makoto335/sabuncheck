基子を使った型パラメータの型議の両万が使わてています。 varは、代入さ

れる型がAroystクラスであることがわかっているため、Arayiis型として変

数を解羽します。

一か、 verを使って変数を宮言してしまうとダイヤモンド注邊子は数の型を

使って型準語ができません。そのため、0bject型が利用されます。よって、

このコレクションはObjectの集合を扱うことになります。forEachメソッド

では、このObject型のコレクションからObject型の可末を1つずつ取り出して

処理します。 以上のことから、 選択股Cが正解です。                    第13章

[第2再 :習呈6】

52. D、G、H                          EE

インスタンスへのアクセスに関する問題です。

インスタンスへのアクセス方法には、「フィールドに直接アクセスする」 「メ

ソッドを呆び出す」の2通りがあります。どちらの場合であっても、「参

照フィールド名」 や、「参照 メソッド名] のようにインスタンスへの参照が

不可欠です。

設問のコードでは、変数tが参照しているTestのインスタンスにアクセスしま

す。追Aは、 変数使わずtisを使ってアクセスしようとしています。 こ

のthisは、呼び出し元のMainクラスへの参昭を表しています。また、manメソッ

ドはstatcなメソッドなので、インスタンスへの参評を表すtnisを使うことは

できません。よって、 誤りです。

選択陸6は、変数名だけを記述しています。これではTestのインスタンスでは

なく、Mainクラスのフィールドにアクセスすることになりますず。よって、誠

りです。

人選択了Cは、メソッド名を記述していません。インスタンスが持つメソッド


--- picture_0029.png ---
を呼び出すには、「参照. メソッド名|のように記述しなければいけません。よっ
て、 誤りです。
選択肢Dは、「参照.フィールド名| の圭式で、かつ変数tを使ってmumフィール
ドに0を代入しているため、正しく値が変更されます。
選択肢は、変数(で参照できるインスタンスのgetNumメソッドの呼び出し結
果に0を代入することなを意味します。 当然、戻D値に仁を代入することはで
きないため、 誤りです。
選択陸Fま、modiメソッドを使ってnumフィールドの値を芸更しようとして
います。Ttstのインスタンスは、コンストラクタで100という数合を与えられ、
変数numの値は100で初期化されています。そのため、numフィールドの値
を0にしなければいけません。しかし、modiyメソッドは、 受け取った引数
をnumフィールドに吉算代入しているので、「100+0」 という式になってnum
フィールドの人寺は100のままです。よって、 誤りです。
選択肢Gは、numフィールドの値をマイナス演算子で反転させて-100にして、
rmodiメソッドの引数として渡しています。modiiメソッドは、受け取った
認をnumフィールドに名引代入しているので、「100+C100)!という式になっ
てnumフィールドの値は0になります。
選択股Hは、選所科Gのようにnumフィールドの値をマイナス演算子でプラス
ノマイナス反転させるのではなく、getNumメソッドの戻り値を反因させてい
ます。getNumメソッドは、numフィールドの舘を戻すため、modiyメソッド
では 「100+(-100)] という式が実行されて、numフィールドの値は0になり
ます。

【穫6章 : 問題7、第7草 : 問題18】
フィールドのデフォルト値とオーバーロードされたコンストラクタのほび出
しに関する問題です。
インスタンスのフィールドは、 明示的に初其化しなければ、 自動的にデフォ
ルト値で初期化されます。 整数型であれば0、浮動小数点数型であれば0.0、
文字型であれば "Wu0000、真偽型であればfalse、参照型であればnullで初期
化されます。
設問のMamクラスにはオーバーロードされたコンス トラクタが2種類用奄
れています。1つは引難なしのコンストラクタ、もう1つはばmt型の細を受け
取るコンストラクタです。

582


--- picture_0030.png ---
rmainメソッドでMainクラスのインスタンスを生成していますが、このとき
使っているのは引著ありのコンストラクタです。 そのため、このインスタン
スのnumフィールドには20が代入されます。一方、valフィールドには何も倍
が代入されないため、デフォルト値であるnullのままです。 以上のことから、
コンソールには[null 20」 と表示されます。よって、選択段Aが正魚です。
【第6章 : 問題17】
54. A、E                                    EEEE
インタフェースの特徴に関する問題です。
インタフェースには、次のような特徴があります。
・ 公開するためのものなので、publicなメンババを定王する
インスタンス化できない
・捧事メソッドを定義できる
デフォルトメソッドとstaticメソッドとして実装を定義できる
・ーデフォルトメソッドとstaticメソッドから利用されることを想定して、
prvateな具象メソッドを定葬できる
・ 定数は定義できるが、フィールドは定義できない
第13章
選択肢Aは、実装を持たない揚氷メソッドの表言です。abstractで修師され
ていなくても、較庄的にabstractrであると解入されます。
選択肢Bは、finalで油祭メソッドを宮言しています。finalは変更できないこ
とを宣言するものですが、この抽象メソッドはインタフェースを実更したク
ラスによってオーパーライドされるために存在します。つまり、変更される
ことが前揚となっており、インタフェースに定義する担計メソッドをfinalで
修師することはできません。
選択生は、実装を持つ具吉メソッドを定巻していますず。 インタフェースには、
デフォルトメソッドとsaticメソッド、およびこれらのメソッドから利用され
るprvateメソッド以外の只色メソッドを定養することはできません。
選択板pは、インスタンス変数を宮言しています。インタフェースには値の
変更ができない定数しか宣言できません。
選択段ほは、abstractを付けて抽名メソッドを宣言しています。 インタフェー
スに定美する抽旬メソッドは、abstractを付けなくてもabstractであると解選
されますが、明示的に付けても問題ありません。
選択科fは、メソッドをprivateで修師して非公開にしています。インタフェー


--- picture_0031.png ---
スの琶象メソッドは、公開され、実中するクラスが実するために存在しま
す。 よって、抽銚メソッドをprvateで億全することはできません。
選択陵Gは、finalを付けて具象メソッドを定葉しています。 選択邊と同、
インタフェースに具齋メソッドを定義するてとはできません。
EER|
55. E
抽応メソッドの実装に関する陸題です。
インタフェースや抽象クラスに定義された抽象メソッドは、 実現または株
した具旬クラスが実装を定閉しなければいけません。もし、すべての負象メ
ソッドが上只祭クラスで実装されなかった場合には、そのクラスは実行できな
いコードを持つためコンバイルエラーとなります。
設陸のコードでは、インタフェースAを素したインタフェース8を定伏し、
さらにそのインタフェースを実現した扶祭クラスC、そしててを浴承した具球
クラス0を定散しています。
酸問のクラスとインタフェース】
ECS23|
A
ECS323|
に
leWect
このような実現や綴承関係のうち、測象メソッドはインタフェースAの
sampleメソッドとインタフェースBのtestメソッドの2つです。そのため、 具
衣クラスである0クラスは本方の実狼を持たなければいけません。しかし、D
クラスに実装されているのはtestメソッドだけで、sampleメソッドはありま
せん。よって、Dクラスはコンバイルエラーとなります。以上のことから、
選択Eが正解です。
なお、継承はクラス間だけでなく、インタフェース間でも行えます。インタ
フェースとクラスの間は矢承ではなく、 実直になるので混乱しないように注
京しましょう。
584                                              [第7 : 骨題8.15


--- picture_0032.png ---
56. B                                       にPsss |
代入流算子と演算子の人先頭位に上関する問題です。
変数に舗を代入するには、右オペランドの演算が総わっている必要がありま
す。設刷のコードs行目の式は、右から順に実行していきます。 実行順は、
 次のとおりです。
①⑪ 「a/ 2」 で結果の2を取り出す
⑧ 「b - = 2] を展開して「b = b + 2] を実行し変数bに計算結果の10を代
入する
③ 変数bの値を秦数(に代入する
よって、 変数3は4のまま変わらず、変数は10に、変数とも10になっているこ
とがわかります。以上のことから、選択箕Bが正解です。
【第3斉 : 商題1】
57. A                                       にPsss |
インボート二言に関する周題です。
インポート宣言の記六方法には次の2通りがあります。                        第13章
利用するクラスの完全公飾クラス名をそのまま記述する
・クラス名の前分にアスタリスク 「[*」 を記述して、そのパッケージに属す
るすべてのクラスを対象とする
設間のMainクラスはsampleクラスを利用しています。このSampleクラスの湊
人修飾クラス名は、 陵文におあるとおりeS7.b.5ampleです。以上のことから、
選択科Aが正釘です。
選択肢Bは、バッケージ名だけを宮言しています。バッケージ内のすべての|
クラスを対象とする場合には、「import ex57.5.*:| のように記述しなければ
いけません。
選択自とDは、完全倍分クラス名ではなく、クラスファイルの配置場所でお
るbinも記述されています。 配置場所はコンバイル時や実行時にクラスパスで
指定するものであり、インボート宮言では指定しません。
[第1章 : 問還1、3】


--- picture_0033.png ---
58. C                                       にP5s9 |

Stringの特徴に関する問題です。
stringは、immutable (不変) なクラスです。つまり、メソッドを呼び出して
も内部の文字列データを変更せず、別の新しい文字列を生成して戻します。
設問のコード3行目では、「A] という文字列を持つStringインスタンスを生成
し、変数。でその参照を保革します。次に、concatメソッドを呼び出して文
宇列を連結し、 [AB] という文字列を持つ新しいStringへの参照を戻します (4
行目)。このコードでは、新しいstringへの参照で変数を上者きしています。
次に「C]」という文字列を持ったStingインスタンスを生成し、 6行日では変数
ュで参照するインスタンスのconcatメソッドを呼び出して文字列を連結してい
ます。concatメソッドは、「ABC] という新しい文字列を持つStringインスタ
ンスへの参照を戻し、変数aを上書きします。
7行目では、変数aで参照するインスタンスのreplaceメソッドを呼び出し、イ
ンスタンスが持つ「ABc] という文字列のCをDに書き換えます。このとき、
stringは内部の「ABC] という文字列を変更せずに、CをDに書き換えた「ABD]
という文字列を持つ新しいStringインスタンスを生成して、その参照を戻し
ます。しかし、7行目のコードでは、この参照を受け取っていません。また、
変数aの参照先も変更していないため、その参照先にあるstringインスタンス
の「ABcl という文字列は変わっていません。
8行目では、変数ぉで参照するインスタンスのconcatメソッドを呼び出して
文字列を達結しています。その結果、「A8CC] という新しい文字別を持った
stringインスタンスへの参照が戻るので、この参照で変数aを上圭きします。
よって、コンソールには 「ABCC] と表示されます。以上のことから、選択肢
Cが正解です。

【第2華 : 習題10、14、17】

59. A                                       にPss9 1
ポクシングに関する問題です。
 プリミティブ型とラッパークラスの演算では、自動的にラッパー型からブプリ
ミティブ型へのアンボクシングが実行されます。プリミティブ型からラッ
バー型へのボクシングではない点に注意しましょう。
設問のコード3行目では、int型の変数numを宣言し、10で初期化しています。
4行目では、 10という値を持ったInteger型のインスタンスを生成し、Integer弄
586


--- picture_0034.png ---
の変数walでその参照を扱っています。
ニー演算子を使ってin型とInteger型を比較していますが、数値と参照では比
載できないため、オートアンボクシングによってコンバイル時にコードが変
換されます。 具体的には、IntegerクラスのintValueメゾッドを使ってインスタ
ンス内部にあるint型の悟を取り出して比較します。 そのため、 5行目のコード
では、10と10が等しいかどうかという判定が行われ、コンソールにはtrueが表
示されます。以上のことから、選択肢Aが正餅です。

【第6章 : 問題12】
バッケージとアクセス制御に関する問題です。
設問のコードでは、AクラスとBクラスは異なるパッケージに語しています。
異なるバッケージに層しているクラスを利用するには、インポート宣言をす
るか、完全修飾クラス名で記述します。
sample.subパッケージに属する8クラスからsampleパッケージに属するAクラ
スにアクセスするには、sampleパッケージをインポート宣言する必要があり
ます。よって、sample.subバパッケージをインポートしている選択肢Cは誤りです。

第13章

選択肢Bは、使いたいクラスが所属するパッケージを正しく宣言できていま
す。しかし、この宣言はクラスを完全修飾クラス名で記述することでコード
の可読性が苦しく低下するのを避けるため、短編表記で宣言しているに店ぎ
ません。つまり、設回の条件である「Bクラス内から4クラスにアクセスして
いる」ことにはなりません。選択肢BとDがセットで記述できれば設問の条件
を満たしますが、選択できる選択肢は1つだけです。
以上のことから、完全惨飾クラス名でクラス名を記述している選択肢Aが正
解です。

【第1章 : 問題3】
continueによる制御に関する問題です。
設問のコマンドでは、a、b、cの3つの起動パラメータを与えてプログラムを
実行しています。for文では、まず起動バパラメータを表示し、その後switch文
で分引処理を行っています。
switch文では、値がaの場合、bの場合、それ以外の場合で処理を分岐してい
ます。aの場合は、値を表示するとcontinueでfor文の更新式に戻ります。 b
の場合は、値を表示するとfor文のカウンタ変数iをデクリメントしてから
continueでfor文の更新式に戻ります。一度デクリメントしてから、更新式で


--- picture_0035.png ---
インクリメントするので、 変数の値は変わりません。 そのため、また同じ起
動パラメータbな処理することになり、bを表示し続ける舞限ループに陥りま
す。 以上のことから、涯択有8が正解です。
[第3再 :問量19、第4章 : 問題15]
62. A                                       EEETI
stoticに関する隊還です。
staticなフィールド (クラス変数) は、インスタンスごとに待理されるのでは
なく、クラス単位で管理されるフィールドです。 そのため、statcフィールドは
そのクラスから作られたすべてのインスタンスで共有されるフィールドである
ともいえます。
設開のコードでは、staticフィールドを持つTestクラスのインスタンスを2つ
作っています。その後、それぞれのsampleメソッドを呼び出していますが、
このタイミングでwhile文によって5回インクリメントされます。このwhilc文
の制御に使っているcountフィールドはstaticではなく、インスタンスごとに
保持するデータです。しかし、 もう1つのwalueフィールドはstadcであるため、
sampleメソッドが呼び出されるたびに5ずつ増えること(になります。 設陸の
コードでは、sampleメソッドを2回呼び出しているため、valuveの値は5、10と
増えていきます。よって、コンソールには10が2回表示されます。以上のこ
とから、 選択及Aが正解です。
なお、staticフィールドの参照は、インスタンスへのお照変数を使うように記
述しても、コンバイル時に次のようなクラス名を使った参に変更されるこ
とも訪れないようにしましょう。
還 コンバイル前
System.out.println(a.value + "。 " + b.value):
較コンバイル後
System.out.println(Test.value + "。 * ・ Test.valuel:
[基5音 :半51
588


--- picture_0036.png ---
while文とdo-while文に関する問題です。

while文とdo-while文の遅いは、条件判定をしてから繰り返し処理をするか、
繰り返し処理をしてから条件判定するかという、条件の評価タイミングの
違いです。 実際の試験では召り返し構文についての問避は、すべての和選択財
で1つずつ値を変更しながら見ている余裕はありません。そこで、条件式の
数値を使って考えます。

設問のコードでは5つの要素を持つ配列を宣言、初期化し、その後、配列の
要素数を持った変数x*を作っています。変数xには、配列の要素数である5が入っ
ています。

選択肢Aは、xの値が0bL上であれば繰り返し処理をするという条件になって
います。絆り返しを始める段階の変数xの値は5で、これは0以上であり条件
に合致するため、繰り返し処理を実行します。この処理では、配列のx番目の
要素を取り出してコンソールに表示していますが、 変数xの値は5であるため、
0から番号が始まる配列にとっては、6番目の要素を取り出すというコードに
なります。 配列の妄素は5つしかないため、このコードを実行すると配列の
要素外アクセスを表すArrayindexOutOfBoundsExceptionが発生します。以上の     第13章
ことから、選択肢Aは誤りです。

選択肢Bは、dp-while文なので、まず繰り返し処理が先に実行されてから条件
判定をします。繰り返し処理では、変数xの値をデクリメントで1減らして4
にしてから、その添字の要素を配列から取り出してコンソールに表示してい
ます。その後、変数xの値が0よりも小さくなるまで処理を繰り返します。問
評は、 変数xの値が1がからデクリメントされて0になり、0番目の要素をコンソー
ルに表示し、条件判定をしてからです。この召り返し条件は、変数xの値が0
よりも小さくなるまで実行されるため、 0のときはまだ繰り返しをしなければ
いけません。そのため、xの値がデクリメントされて0から-1になって、-]番
目の要素をコンソールに表示しようとしたタイミングで、配列の要素外アク
セスを表すArraylndexOutOfBoundsExcepticnが発生します。以上のことから、
選択肢Bも誤りです。

選択肢Cもdo-while文なので、まず繰り返し処理が先に実行されてから条件判
定をします。この処理では、配列の*番目の要素を取り出してコンソールに表
示していますが、変数xの慎は5であるため、選択肢4と同様に6番目の要素を
取り出すというコードになります。よって、このコードを実行すると配列の
要素外アクセスを表すArrayindexOutOfBoundsExceptionが発生します。以上の
ことから、選択肢Cも誤りです。


--- picture_0037.png ---
選択肢DとEは、実は同じコードです。有選択肢Dはデクリメントしてからコン
ソールに表示していますが、 選択肢Eは、前置デクリメントでデクリメント
してがからコンソールに表示しています。どちらの条件もxの値が0よりも大き
ければ繰り返し処理をします。つまり、変数xが5一1の間、繰り返し処理を
実行することになります。変数xがSsのとき、デクリメントされて5が4に減っ
てから、その添字の値がコンソールに表示されます。また、変数xXが1のとき
はデクリメントで1が0に減ってから、その添字の値がコンソールに表示され
ます。以上のことから、選択肢DとEが正解です。
【第4章 : 問題13】
64. C                                       EEE
注算子の侵先順位に関する問題です。
試験対策としては、「当算子の優先順位は数学と同じ] と覚えておきましょう。
設問のコードでは、加算代入「+=] とカッコ 「()」、四則演算の優先順位が
問われています。
代入演算子 「=」を使うと、右辺が式の場合には式が先に実行され、得られ
た値が左辺に代入されます。加算代入の場合も同様で、式の結果と変数の値
が足し算された結果が変数に代入されます。
設問のコードでは、代入演算子の右側の式は次のようになっています。
・2・)/1-2
カッコと皿有演算ではカッコが優先されるため、カッコ内の 日*2 とい
う式が先に実行されます。四則演算の優先順位は数学と同じで、乗算・除算
が加算・減算よりも優先されます。よって、邊* 2 - 員 であればぼ日*2] が
先に計算され、その計算結果とjが加算されます。先ほどの式のjとを値に変
更すると、次のような計算式になります。
(2*212)73-2
まず、2X2が実行され、その結果の4と2が加算されます。そのため、カッコ
内の式を実行すると次のようになります。
573-2
前述のとおり除算は減算よりも優先されるので、6が3で割られて、その結果
590          から2を引きます。よって、式の結果は0です。最後に加算代入演算子を実行


--- picture_0038.png ---
します。次の式のように、変数にiの値である3と弐の結果である0を足した
値を代入します。
310
以上のことから、 変数の値は3となります。よって、 選択肢Cが正人です。
【第3章 : 問皿1カ|
に                                       EE
インクリメントの前攻と後詩に関する問題です。
インクリメント演算子やデクリメント演算子は、前填と後半では加算や減算
のタイミングが変わります。 前置の場合は、加算や減算がされてから左右オ
ベランドの処理が実行されます。一方、後置の場合は、左右オペベランドの短
理が実行されてから加算や当算が行われます。
設問のコードでは、 it六の条件式でインクリメント演算子が前計されたものと
後計されたものが比較されています。 変数aは後置、変bは前填されている
ため、秦数5の加引が実行されてから比較され、そのあとに変数aの加箕が実 第13章
行されます。 そのため、if入の条件式は、加算されて2になった変数bの値が2
のままの座数3よりも小さいかを比較することになります。この結果はfalseと
 なるため、elseプロックが実行されてコンソールには 「B] と表示されます。
条件式の評価が終わったタイミングで、変数4の値も加算されます。 そのため、
コンソールには吉算後の「3:.2] と表示されます。以上のことから、選択肢D
が正解です。
[第3草 : 問題2]
66. E                                       EEE3
配列に関する問題です。
オブジェクト型の形別の可素は、インスタンスを作っただけでは空 (nulD
の状態です。インスタンスを別に作って、その参照を配列の要素として代入
しなければいけません。
設理のsampleクラスでは、 3つの要素を秒つItem配列のインスタンスを生成し
ています (3行目)。この配列インスタンスはまだitemのインスタンスへの参
隅を1つも持っていないため、その壁素はすべてnullの状態です。その後、配
列の2番目と3番目の要素に作成したItemのインスタンスへの参照を代入して
います。しかし、 1番目の要素 (添字が0番) は令震としてnullのままです。そ


--- picture_0039.png ---
のため、撤拓for文で杏素を取り由し、その要素のnameフィールドの値を参
照しようとしたタイミングでNullPointerExceptionが発生します。
以上のことから、選択到が正本です。

[第5音 : 半題51

67. B                                       EEEE
Javaの科能について正しく理解できているかを確認する問題です。

Javaでは、バパイブライン処理をサポボートするような標準ライブラリを提供し
ていません (居所4)。

Javaでは、JVMが中間コードを読み込み、 ネイティブコードにコンバイルし|
ながらブログラムを実行します。このとき、頻没に使われるネイティブコー
ドはメモリ上にキャッシュされるため、コンパイル持問が短納されます (選
択肢B)。

選択且cは「ガベージコレクションをアプリケーションのコードよりも優先
する」 とありますが、ガページコレクションはJVMがCPUの使用率などを考
司しながら、いつ実行するかを決めます。そのため、アプリケーションが負
 荷の高い処理を行っているときは、ガページコレクションの優先順位が下が
ります。

Javaはマルチスレッドによる聞列処理をサポートしていますが、ライブラリ
として提供されているだけでおあり、Javaが自動的に並列怒理を行うわけでは
ありません (避披D)。

68. B、F                                    EE
オーパーライドとオーバーロード、そして共変戻り値とジェネリクスに関す
る問題です。
オーバーライドしたメソッドのジェネリクスの型パラメータは、完全一致で
なければオーバーライドとして晃なされません。そのため、設天のコードの
1eslメソッドは、次の条件を滴たさなければいけません。

型パラメータにcharSequence型を指定したSet型の引落を受け取ること
型パパラメータにNumber型を指定したLisr型の戻り値を戻すこと
そのため、戻り値錯もしくは3数の型パラメータが異なる選択肢A、C、D、E
は誤りです。
中択肢6は、引数の型をset引から実装クラスであるTreeset型にしています。
592


--- picture_0040.png ---
そのため、オーバーロードとして扱われ、ジェネリクスの型パラメータが一
致しなくてもコンパイルエラーにはなりませんが、次のように@Overrideア
ノテーションを付けるとコンバイルエラーになります。
団 選択肢6の記述をオーパーライドとした場合
8OCerride でオーバーライドを示するとコンバイルエラー
public List<nteger> test(Treeset<String> s) 【
sern mb

1
選択革Fは、引数の型とジェネリクスの型パラメータは一致していますが、
戻D信措が異なります。しかし、戻り値型として指定されているArayListク
ラス|はLitインタフェースの実装クラスであり、馬近性があります。 そのため、
共共民り仁として解羽されて、コンバイルエラーとはなりません。

[第7間 半題1

69. C                                       EEZ

二重ループに頻する聞題です。                                 第13章
設届では2つの要素を持つ配列を用意し、その可素数分だけwhile文の庫り返
し負理を実行しています。whie文の中では0で初若化された変狂を宮言した
あと、dorwhie文aryの要素を1つすつ取り出しながら、その文字数を数え
て採り返し笛の制害行つています。
dowhile文の特徴は、条件判定をする前に必ず一度は線り返し抽理を実行
ることです。 そのため、変数の値へのインクリメントが1回実生されてから、
条件式を判定します。arrayの要素の文字数を数えていますが、 要素は1文字
しかないため、do-while文の条件式はfalseを戻し、do-while文を抜けてしまい
ます。
変数arayの要素は、[Al と「B] という1文字しかない文字列なので、
dorwtie文の捧り返し私理が一度行され、条件式でdoawhie文から抜けるの
を繰り返すだけになります。よって、 の値が1より大きくなることはありま
せん。 以上のことから、 選択肝が正解です。

[第唱 : 問是1、21


--- picture_0041.png ---
配列の生成に関する問題です。
配列の生成に関する問題では、次の点に注意します。
1. 変数宣言時に大カッコ「[]」 があるか (大カッコは省略不可)
2. 変数宣言時に要素数を指定していないか
3. インスタンスの生成でnewを記述しているか
4. インスタンス生成時に要素数を指定しているか
5. [1以外のカッコを使っていないか
選択肢AAは、上記に沿って、正しく記述されています。
選択肢6Bは、インスタンス生成時にnewを記述しておらず、上記の2に反して
います。 配列はインスタンスなので、生成しない限り使えないということを
忘れないようにしましょう。
選択肢Cは、変数宣言時に、配列型変数であることを表す大カッコを記述し
ていません。 上記の1のとおり、大カッコを省略することはできません。
選択肢Dは、 変数家言時に要素数を指定しているため、上記2に反しています。
変数は配列のインスタンスへの参照を保持するための器に過ぎず、秋数内に
配列が作られるわけではありません。いくつの要素を扱うかという情報が必
財なのは配列のインスタンスです。

【第5章 : 問題2、7】
非検査例外に関する問題です。
設問のsampleメソッドは、引数がnullかどうかで、検査例外もしくは非検査
例外のどちらかをスローします。 検査例外をスローするメソッドは、throws
でスローする可能性を宣言しなくてはいけません。そのため、sampleメソッ
ドはthrowsでExccptionをスローする宣言をしなければなりません。
sampleメソッドで検査別外をスローすることをthrowsで宣言すると、sample
メソッドをを呼び出しているmainメソッドでもその対応が必要です。しかし、
mainメソッドでキャッチしている例外はRuntimeExceptionであり、Bxception
 をキャッチできません。そのため、mainメソッドでExceptionをスローするご
とをthrowsで宣言するか、キャッチする例外の種類をRuntimeExceptionから
Exceptionに変更するかのどちらかで修正しなければいけません。
以上のことから、有選択肢CととDが正解です。

【第10章 : 問題11】

594


--- picture_0042.png ---
72. C                                       EE
配列の要素の初期値に関する同題です。
配列のインスタンスを作ったときに初期化子などで明示的に初期化しない限
り、各要素は自動的にデフォルト悟で初期化されます。扱う要素の型が整数
型なら0、浮動小数点数型なら0.0、真偽値型はfalse、文字型なら\u0000、参
陣型ならnullで初期化されます。
設問のコードでは、int配列型の変数とInteger配列型の変数を用意し、それ
 ぞれ3つの空の要素を持つた配列のインスタンスを生成し、変数に参照を代
入しています。これら2つの配列の要素は明示的に初期化されていないため、
デフォルト値で初期化されます。そのため、5…7行目の繰り返し処理は0が3
つ並んで表示され、10一12行目の繰り返し処理ではnullが3つ並んで表示され
ます。以上のことから、選択肢Cが正解です。
[第5 同呈5
73. C                                       に P529 |
演卸の優位と+江和子を使った文字連結に関する同量です。
設両のコード3行目のように文字列と数値を+沈算子で加算した場合、数値が    第13章
文字列に変換されて文字列連結として負理されます。そのため、コンソール
に 「result=234] と表示されます。
一方、4行目の式には+ 演算子に加えて*演算子も訪まれます。名算と乗算で
は、数学と同じように乗算が朝先されます。そのため、数雨が文字列として
連結される前に乗算が実行され、次のような式に変換されます。
団 設問のコード4行目
"result=*+2+ 12
よって、4行目はコンソールに「result=212] と表示します。以上のことから、
選択邊が正解です。
【第4華 : 財丁18】


--- picture_0043.png ---
74. C                                       EE
配列のcloneメソッドに関する問題です。
ddoneメソッドは、 新しい配列を作り、その配列に同じ要素への参照をコピー
します。そのため、cloneメソッドで作られた複製の配列と元の配別は同じ参
先を共有します。
設半のコードでは、「arayl.clone()] でarray1の参照先のコピーをarray2に代
入しています。 そのため、array1とarray2は同じ要乏への参照を共有している
ことになり、array1の要素を変更するとarray2が参照している要素も変更され
ます。 よって、同一性検証する==芝算子はueと判定されます。 以上のこ
とから、 選択諾てが正健です。
一万、aray1の2番目の要素 (char下列) のdloneメソッドを合った 「arayilil
dlonm0] では、新しい配列を作り、その配列に同じ構素 (char型の値) をコピー
し直します。 新しい配列を作っているため、array1とaray3は同じ値を持って
いる異なる配別への参照を持つことになります。 よって選択彼Aは誤りです。
選択肢Bは2次元配列であるarray1の2番目の要索 (char本別) と1次元配別で
あるarray3の2番目の要素 (char) を比較しているため、コンバイルエラーと
なります。よって、 記Dです。
配列は、javaang.Objectクラスを槍承したクラスとして実装されています。
そのため、Objectクラスに定義されているcqualsメソッドなども持っていま
す。Objsctクラスのequalメソッドはオーバーライドされることが前提のメ
ソッドで、オーバパーライドしなかった場合は同人性ではなく同一性を検証し
ます。array2には、array1のclonsメゾッドの結果作られた新しい配列への参
照が入っつています。そのため、array1とarraY2は異なる参照を持っていること
から、equasメソッドはfalseを戻します。よって、 選択統Dも説りです。

[第5章 : 隊題10]

75. C                                       EE
同名のフィールドとローカル変数に関する職題です。
同名のフィールドとローカル変数がある場合、thisを使ってフィールドであ
ることを明示しない限り、ローカル変数が硫先されます。よって、thisを使っ
てフィールドであることを明示して、引到で受け取った値を代入している選
沢肢が正解です。
選択設ねは、引数で受け取った値を、引数として宮言した変数に再代入して
いるだけで、フィールドの値を変更していません。

596


--- picture_0044.png ---
信択6は、引数で受け取った値を、新しいローカル変数value(に代入してい
ます。そのため、フィールドの仁を変更していません。
信択了じは、thsを使ってフィールドであることを明示していますが、紹を
宜言していません。そのため、フィールドの値をフィールドに再代入してい
るだけとなります。

(7:商題1
ラムダ式に関する問題です。
設闘では、javaang.StringクラスのtoUpperCaseメソッドで [helol という
文字列を [HELO」 と大文字に変換して表示しようとしています。 設問のコー
ドの空機には、この処理を行うためのラムダ式が入ります。選択肢BとEは同
じ高味のラムダ式です。 選択下Eが中カッコ「( )」を使った記述で、 選択上
が中カッコを演路し、かつ引数の型家計を省略した記述です。以上のことか
ら、選択股BとEが正解です。
信択設A、C、Dはメソッド参昭の構文に近い記述ですが、メソッド参照の場
合はメソッド名の光ろにカッコ「()」を付けません。なお、朋所工が以下
のようなコードであれば正解となります。

第13章

較 メソッド参照
SHring::toUnperCsse: でメソッド参照にはカッコを付けない
人択肢CやDは義数*を使っていますが、設着のコード内に変・を宣言してい
る箇所はありません。

[第5 : 居呈2
列に関する負頭です。
throws匂には、そのメソッドがスローする可能性のある例外の各類な宮言
します。 例外もクラスであるため、ポリモーフィズムを利用して、サプクラ
ス型の別外のインスタンスへの参照をスーパークラスの型で了うことは可
能です。そのため、設問のコードであればsubsampleExceptionクラスのイン
スタンスへの参照をsempleException更で扱うことができます。throws名に
sampleExceptionが宣言されていれぼ、subsampleExceptionをスローすること
は可能です。以上のことから、吉択肢Aが正解で、選択Dは癌りです。
semplebceptonクラスはjava_ang.yceptonクラスを継承している検査例外で
す。そのため、testXソッドを使うメソッドでは例外処理をしなければコン


--- picture_0045.png ---
バイルエラーとなります。よって、選択枝Bは誤りです。
メモリ不足などプログラムで対処しきれないようなトラブルが発生したこと
を表すのはErrorクラスとそのサプクラスの役割です。Samplexceptionのスー
パークラスであるExceptionは、プログラムで対処できる範囲のトラブルを表
現するためのクラスです。よって、選択肢Cも誤りです。
[也10畔 :委11
78. B                                       EE
ローカル変数の宣言に関する問題です。
メソッド内に記述したコードは、1行目から順に実行されていきます。そのた
め、ローカル変数を使うには、それを使っている行よりも上の行で十言して
おく必要があります。
設問のコードでは、4行目で変数(にbの値を代入しています。しかし、変数b
の宣言は次の5行目で行われているため、宣言していない変数を使っている
てとになり、この4行是でコンバイルエラーが発生します。よって、選択肢B
が正解です。
なお、フィールドやメソッドのようにクラスのメンバとして宣言する場合、
順番は関係ありません。フィールドやメソッドはランダムにアクセスされる
ため、それを使っている行よりも上で誤言する必要はありません。
【第6革 : 隊題9】
79. A                                       EE
cloneメソッドを使った配列のコピーに関する再題です。
てcloneメソッドを使うと、同じ値を持つた配列インスタンスが複製されます。
 そのため、array2の要素を変更しても、arrayに影響を及ぼすことはありません。
よって、 選択膨Aが正解です。
cloneメソッドはObjectクラスに定義されているメソッドで、すべてのインス
タンスが持っています。よって、コンバイルエラーが発生することはありま
せん。

--- picture_0046.png ---
switch文に関する問題です。

switch文の問評で気を付けるべきポイントはcase式でbreakがなかった場合
に、あとに続くcase式の処理が次々と実行されることです。 設問でもbreakを
記述していないcase式があります。これに注意して、どのような動作をする
かを考えましょう。

設問のコードでは、「Al 「Bl 「C| 「D] の4つの文字列で初期化されたstring
束の要素を持つ配列を作成し、要素を1つずつ取り出しながらswitch文で処理
を分財しています。

最初に、Aのcase式ではnumの値を-1 しています。numの値はOから始まるので、
この時点で値は-1となります。 次にBのcase式では、numをインクリメントし
て値を-1から1つ増やして0にします。その後、breakがないため、Cのcase式
も続いて実行され、numの値に2が加算されます。この時点でnumの値は2と
なります。続いて、Cのcase式ではnumの舘に2が加算され、慎が4になりま
す。最後のDのcase式は何も処理がありませんが、breakしていないので、そ
 のままAのcase式が実行されます。そのため、numの値が-1されて3になります。
Aのcase式はbreakが記述されているので、caseの判定は終わります。以上の    第13章
ことから、コンソールには3が表示されます。よって、選択肢Aが正餅です。
