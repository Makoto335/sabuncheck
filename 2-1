--- picture_0001.png ---
第13章 総仕上げ問題@
解    ヒーココ
和
検聞例外と非検査例外の違いに関する問題です。
java.lang.Exceptionクラスのサブクラスは、例外処理の記述が必要な検査例外
です。 一方、Exceptionクラスのサブクラスでも、RuntimeExceptionクラスの
サブプクラスは例外処理が必須でない非検査例外です。
設問のコードで使われているFileNatFoundExceptionは、java.io.IOException
 のサブクラスです。 IOExceptionはExceptionクラスのサブクラスであるため、
FileNotFoundExceptionクラスは検査例外の一種ということになります。
また、throwではFileNotFoundExceptionのインスタンスへの参照をスローし
ているものの、throwsではスーパークラスのIOExceptionクラスをスローする
可能性があると宣言しています。そのため、FileNotFoundException型では例
外をキャッチすることはできません。よって、 選択肢A、B、C、Eは誤りです。
1hrowsで宣言しているもう一方のIndexOutOfBoundsExceptionは、Runtime
Exceptionのサブクラスです。そのため、例外処理のためにcatchブロックで
キャッチしなくてもコンパイルエラーにはなりません。以上のことから、
1OExceptionをキャッチするだけでコンバイルは成功します。よって、有選択設
Dが正本です。
【第10章 : 問題11】
ト-王/ 逢 季]                         EE

オブジェクトの変更可能性に関する問丁です。
 値の変更が可能なフィールドを持つオプジェクトのことを「mutable (可変)
なオブジェクト| と呼びます。 反対に、値を変更できないフィールドを持つ
オブジェクトのことを 「immutable (不変) なオブジェクト」 と呼びます (選
羽肢B)。
オブジェクトをimmutableにするには、次の塵件を満たすように実装します。

setterメソッドを提供しない

参照型のフィールドのためのgetterメソッドで参照を戻さず、 新しいコピー

を作って戻す

フィールドの値を変更するメソッドは、フィールドの信を変更する代わり

に、新しい値を持ったインスタンスを生成し、その参照を戻す

554


--- picture_0002.png ---
・ すべてのフィールドをfinalかつprivateにする (選択肢C、D)
・ サブクラスによるメソッドのオーバーライドを許可しない (選択肢A)
なお、最後の 「オーバーライドを許可しない] は、サプクラスでフィールド
を追加して、オーバーライドしたメソッドで変更できるようになるためです。
ポリモーフィズムを使って、サゴブクラスのインスタンスへの参照をスーパー
クラス型として扱うと、immutableなはずのオプジェクトが変更できてしま
うという状況が発生します。このようなことを防ぐために、クラスをfinalで
宣言するなどして紹承そのものを禁止したり、メソッドをfinalにしてオーバー
ライドを禁止したりします。

【第2草 : 問題10】
型変摘に関する問題です。
型変換には、キャスト式が不要な暗黙の型変換と、キャスト式が必要な明示
的な型変換の2種類があります。 設問の6一9行目の代入式は、キャスト式が
記述されていないことから、暗黙の型変換を行っていることがわかります。
購圭の型変換は、データ型を変換してもデータの欠損がないことが条件です。    第13章
 そのため、小さなデータを大きな型の変数に代入するときなどは、暗諸の弄
変十が可能です。
設届のコードでは、int型、float型、double型の3つの変数を用意しています。
このうち、floatとdoubleは浮動小数点数型でちあることに注意してください。 6
行目では、float型の変数bの値をint型の変数。に代入しています。しかし、int
型は加数型でちるため、floatの小数点数を表すことができずにデータの欠損
が発生します。そのため、65行目はコンバイルエラーとなります。これを修正
するには、キャスト式を記述して、データの欠損はない、もしくは無視して
よいことをコンバイラに伝えなければいけません。よって、世択肢Aが正解
です。

【第3章 : 問題3】

4. C、E、F                        EE

推承に関する問題です。
Trashクラスのtestメソッドでは、常にtrueを戻すよう実装されていますが、そ
 のサブクラスであるcacheTrashクラスでは、list凡に引数で受け取った文字別が
存在するかどうかをjava_util.ArrayListのcontainsメソッドを使って調べた結果
を戻します。 にtueを戻すわけではありません。 よって、選択肢Aは誤りです。


--- picture_0003.png ---
CacheTrashクラスは、引数で受け取った文字列をフィールドに代入している
だけで、スーパークラスのdeleteメソッドを呼び出していません。よって、
選択肢8も誤りです。
addメソッドは、Cacheriashクラスではなくスーパークラスに定義があります。
スーパークラスであるTrashクラスでは、listに引数で受け取った文字列を追加
する処理をしているため、選択机Cは正しい説明です。
Trashクラスのlistフィールドにはアクセス修飾子が付いていないため、同じ
パッケージに属するクラスであればアクセスできます。クラスが属するバッ
ケージが異なる場合 たとえサブクラスであったとしてもアクセスできませ
ん。よって、和選択肢Dは語りです。
CacheTrashクラスのflushメソッドは、superを使ってスーパークラスのdelete
メソッドを呼び出しています。よって、選択肢Eは正しい説明です。
CacheTrashクラスのコンストラクタでは、スーバパークラスのコンストラクタ
呼び出しの引数にnullを渡しています。スーバパークラスであるTrashクラスの
コンストラクタでは、受け取った値をaddメソッドに渡し、addメソッドでlist
に値を追加しています。以上のことから、人選択股Fも正しい説明です。

【第7章 : 問題1、2】
ローカル変数の有効細及に関する問題です。
同名のフィールドとローカル変数がある場合、thisを使ってフィールドであ
ることを明示しない限り、ローカル変数が節先されます。
設融のコードのsetvalgeメソッドは、引数で受け取った値と文字列を連結し
て、引数として宣言したローカル変数に再代入しています。そのため、 フィー
ルドvalucの値はデフォルト値であるnullのまま、コンソールには 「nulll と表
示されます。よって、 選択肢Cが正解です。

【第7章 : 隊題18】
問承関邊にあるときのアクセス修飾子に関する問題です。
継承関係にあるとき、サゴブクラスからアクセスできるスーパークラスのメン
パパのアクセス修飾子は、publicかprotectedです。 アクセス修飾子なし(デフォ
ルト) は、継誠関係の有無にかかわらず同じバパッケージでなければアクセス
できません。また、privateは同じバッケージであっても異なるクラスからの
アクセスはできません。

556


--- picture_0004.png ---
設問の4Aクラスは、a、b、cと3つのフィールドを持ちますが、それぞれアク
セス修飾子が異なります。また、Aクラスとそのサブプクラスである5クラスが
異なるパッケージに届していること(に注意しましょう。5クラスからアクセ
スできるのはprotectedで修飼されたフィール ドbとpublicで修帥されたフィー
ルドcです。 フィールドaはアクセス偽飾子が付いていないため、サブクラス
からアクセスできません。 よって、コンバイルエラーが発生するのは、aフィー
ルドにアクセスしたときだけです。以上のことから、選択邊Cが正館です。

【第6章 : 問題26】
型変換に関する隊証です。
数値型は文字に変拉することが可能です。これは、文字が文字番号という数
値で投われているためです。致代な文字に変換するには、次のようにcher弄
の変数に直接数値を代入するかが、数仁弄変数を用意してからキャスト式を記
 述するかのいずれかの方法で行いまず。
団 数全型から文字への変換
char t-97:                                               第13章
int is97:
char (cher)
数箇弄変数をキャスト式なしでchar型に代入することはできないので、注門
しましょう。
設習のコードでは、97と98という仁を持った数休叶変数sとbを宮言していま
す。 その後、それぞれをchar型へのキャスト式で弄季損してからコンソール
に出力しています。97はa、 98はbという文字を表すので、コンソールには |a
bj が出力されます。よって、 選択自Aが正解です。
異なる型に変換する場合、int型からlong型への充換のように暗時の型恋換が
できるものであればキャスト式は必要ありません。しかし、int中とchar弄に
は本来互換住がなgいため、キャスト式存記述する必要があります。 言い問え
れば、キャスト式は安全に型変換できることをプログラマーが明示したこと
になるため、コンバイラは問題なし」と判断して、 実際に弄変剖できるか
どうかに関係なくコンバイルを完了してしまいます。 このため、キャスト式
が記述されている設枯のコードでコンバイルエラーが発生することはありま
せん。よって、 選択肢Cは彰りです。
また、 設問で扱われているshor前やinr型、char天はプリミティブ研であり、


--- picture_0005.png ---
インスタンスの弄変換ができなかったときに発生するClassCastExceptionがス
ローされることはありません。よって、選択肢Dは誤りです。
【第3章 : 陸題3】
スーパークラスのメソッドへのアクセス方法に抽する問題です。
スーパークラスのメソッドをサブクラスから呼び出すには、superを使いま
す。 よって、 選択肢Dが正解です。
設問のコードのtestメソッドがオーバーライドでなければ、選択肢Aのように
1hisを使って呼び出すことも可能です。設問の8クラスのtestメソッドはAクラ
スのtestメソッドのオーバーライ ドであるため、thisを使うと8クラスのtestメ
ソッド内から同じ8クラスのtestメソッドを呼び出す再帰呼び出しになってし
まい、javaJang.StackOverflowErrorが発生します。
選択肢Bのpublicはアクセス修飾子どであり、メソッドやフィールド、クラスの
宣言に使うためのものです。
選択肢Cのnewは、インスタンスの生成陸に使うためのものです。
【第7章 : 問題20、第10章 : 問題17】
ポリモーフィズムに関する問題です。
ポリモーフィズムを使えば、サゴブクラスのインスタンスへの参照をスーパー
クラス型で扱うことができます。その場合、たとえ参照がサプクラスのイン
スタンスに対するものであったとしても、スーバパークラスとして扱われるた
め、サプクラスで拡張した独自のメソッドなどを呼び出すことはできません。
設問のコードでは、Aクラスを継承したBクラスを定義し、Bクラスのインス
タンスへの参照をA型の変数で扱っています。そのため、Aクラスに存在し
ないBクラス和独自のメソッドは呼び出せません。Aクラスに定義されている
setValueメソゾッドはstring型の引数を受け取るものであり、string配列型を受
け取りません。string配列型を受け取るのはBクラスで拡張した独自メソッド
だからです。以上のことから、選択机Eが正餅です。
BクラスはAクラスのサブクラスであるため、Bクラスのインスタンスへの参
照をA型で扱うことは可能です。よって、選択肢入は誤りです。
スーバークラスに定義されているメソッドは、サブクラスが引き継ぎます。
引き継いだメソッドのままでよいのであればオーバーライドする必要はあり
ません。よって、世択肢8も誤りです。
の               BクラスのtestメソッドはBクラス内からしか使わむれていないため、 testメソッ


--- picture_0006.png ---
ドのアクセス修飾子がprivateでも問題ありません。よって、選択肢Cも誤り
です。
Bクラス内では、スーバパークラスであるAのvalueフィールドに直接アクセスし
ている箇所はありません。setValuesメソッドのような公開されているメソッ
ドを経由してyaluegフィールドにアクセスしています。よって、有選択肢Dは誤
りです。

【第7章 : 問題14】
varによるローカル変数の型推論に関する問題です。
varが使えるのはローカル変数の宣言だけです。フィールドや戻り値型など
の宣言には使うことができません。
設問のコードでは、4行日のsampleフィールドの宣言と、5行日の戻り値型の宮
言にvarを使っているため、コンパイルエラーとなります。よって、選択肢A
とEが正解です。

【第2昔 : 敵題6】

    Ln

staticなフィールドの初期化処理に関する問題です。
staticなフィールドは、インスタンスを生成しなくても利用できます。その
ため、インスタンスフィールドのように、コンストラクタを使って何らかの
処理を実行して、初期値をフィールドにセットするということができません。
staticなフィールドに対して、何らかの初期化如理をしたい場合には、static
初期化子を使います。stati初期化子は複数定義でき、定表した順に上から実
行されます。 設問のMainクラスは、1番目のstatic初期化子でnumに10を代入
していますが、2番目のstatic初期化子で20に上書きしています。
また、testメソッドで使っている変数numは、引数で宣言した変数mumです。
同名のローカル変数とフィールドがある場合、thisを使ってフィールドであ
ることを明記すると、ローカル変数が像先されます。そのため、testメソッ
ドを実行してもnumフィールドの値は変更されません。
以上のことから、コンソールに出力されるのは、?番目のstatic初基化子で代入
した20です。よって、選択肢Bが正解です。

【第6草 : 問題22】


--- picture_0007.png ---
12. C、D                      にP51o
ローカル変数の型推論と配列の初期化子に関する問還です。
varを利用したローカル変数の型推論では、代入演濾子の右辺の型からデー
タ弄を推論します。 また、 配列の初期化子「( )」は、代入する変数の型から
配列の型を準誰しまず。
選択上Aは、代入演算子の右辺、左辺ともに推論できる型情報がありません。
よって、コンバイルエラーとなります。
選択肢9は、Double配列型のインスタンスの生成と初期化をしているように
見えますが、 配列のインスタンスであることを示すには、 以下のように大カッ
コ [上 が必要です。よって、選択取Bもコンバイルエラーとなります。
還 pouble配列型インスタンスの生成と初期化
Yar b = ne Double[]lt1.0, 2.0, 3.0, 4.0]: 大カッコが必要
選択彼Cは、Float本列型のインスタンスを生成し、fioat民の要素をポクシン
グして激っています。浮生小数点数のリデラルは、double型として解釈され
ますが、 数條の後ろにfやFを付けることでfloat型であることだを明示できます。
以上のことから、正しくコンパイルできます。
選択服Dは、double中列のインスタンスを生成し、doubleの要素で初期化し
ています。この本文に問違いはなく、正しくコンパイルできます。
[生音 :耳6]
13. C                                   EE
アクセス億導子に関する問題です。
Javaには、アクセス制御を行うための條分子が4つあります。このうち、
異なるバッケージに局しているクラスがアクセス可能なのは、publicと
protectedの2種類です。ただし、protectedについては、継承関係にあるとき
だけという条件が付きます。
設問のコードは、殿なるパッケージに局するsampleクラスとMainクラスを定
養しています。 この2つのクラスは應関係におるため、Mainクラスからは
Publicとprotectedで修師されたものだけにアクセスすることができます。
sampleクラスでpublc、もしくはproteedで修飼されているのは変数cとdの2
 つだけです。以上のことから、選択取Cが正解です。
【第6章 : 半是26]
560


--- picture_0008.png ---
14. p                                       にP512 1
サブクラスからスーパークラスへのアクセス方法に関する問題です。
サブクラスからスーパークラスにアクセスするには、superを使います。た
だし、サプクラスからアクセスできるのは1つ上のスーパークラスだけであ
り、2つ以上、上にあるスーパークラスにアクセスする方法はありません。
設問のコードは、 てクラスで supcrsuper| という具合に、スーパークラスの
スーパークラスと指定しています。 前述のとおり、アクセスできるのは1つ
上のスーパークラスだけであるため、Cクラスはコンバイルエラーとなりま
す。 よって、涯択取DPが正解です。
【第7草 : 問題20】
15. B                                       EEEE
クラスの総束とスーパークラスのコンストラクタ呼び出しに関する問題です。
接了関係にあってもコンストラクタは引き浴げません。 また、サプクラスの
インスタンスを生成する際、スーパークラスのインスタンスも同時に生成し、
スーパークラスのコンストラクタを実行して、スーパークラスのインスタン
スの初若化をしなければいけません。                             第13章
そのため、サブクラスのコンストラクタには、スーパークラスのコンストラ
クタ町び出しのコードが必要です。 設問のコードでは8クラスはAクラスを汗
率しており、クラスのコンストラクタを実行するときには、Aクラスのコン
ストラクタを呼び出さなければいけません。
サブクラスのコンストラクタ内で、スーパークラスのコンストラクタを呼び
出すには、superを使います。入択股4やCのようにthisを使うと、Bクラス
にあるオーバーロードした別のコンストラクタを呼び出すととになり、スー
バークラスのコンストラクタは旦び出せません。
また、Aクラスのコンストラクタはim型の引数を受け取ります。 そのため、
sring型を渡している選択肢Dや、何も渡していない選択肢Eは誤りです。以
上のことから、 選択股Bが正解です。
[第7 : 骨聞20】
16. Dp                                       EE
インポート宣言に関する半贅です。
インポート宣言は、利用するクラスの各ソースファイルに記述します。java
ulLiiを使っているのはsampleクラスであって、 Manクラスではありません。


--- picture_0009.png ---
よって、Manクラスではインボートする必要はありません (選択上C)。
同じパッケージに届しているクラスで記述されていても、ほかのクラスでイ
ンポートする必要がある場合もあります (選択設)。
インポート宣言でアスタリスク 「*」 を使うと、バパッケージ内のクラスやイ
ンタフェースをインポートします。sampleクラスでは、 java_utiバッケージ
に局するすべてのクラスやインタフェースをインポートしています (肖択
D)。 バッケージ内の符定のクラスヤインタフェースだけをインポートする場
合は、クラス名やインタダフェース名まで記述します (選択上8)。
[生計題3
17. A、E                                    |っPs15 1
配列の初期化に関する賠題です。
配列の初期化子「{ }」 を使うと、配列のインスタンス生成と要素の代入を一
六に行うことができます。 初期化子は、 変数宣言と同時にしか使えないこと
に注意してください。 初化子を使う以外にも、たとえばメソッド呈び出し
のき認として流すときなど変牙|に代入する必要がない場合は、次のように無
名記列を作ることで配列のインスタンス化と可素の初化を同時に行えます。
較 無名配列
sample(new int[] (1. 2. 3)):
このコードほは、sampleメソッドを呼び出すときに1、2、3という3つの可素を
持つたimi配列型のインスタンスを生成して、 その参照を引数に渦しています。
掴名門列を作るときには大カッコ [| の中に婁素数を記述しない点も注意
してください。
選択股Aは、int本列型のarrayという傘数を用高して、その容数に無名想列の
インスタンスへの参照を代入しています。舞名配列は、変数に代入しなくて
も位易的に配史の生成や初期化を行うちものですが、このコードのように変数
に代入しても問題ありません。よって、正常にコンパイルされます。
選択6はin配列弄変数を用坦し、3つの可款を持った配別を生成して参照
を代入しています。その後、初化子を使って3つの要素を持つた配列のイ
ンスタンスを生成していますが、前述のとおり初電化子は変数宣言と同時で
なければ使えません。よって、コンバイルエラーとなります。
促択上cは、無名配列のインスタンスを生成し、その参照をDouble本久世の
変数に代入しようとしています。 前述のとおり、舞名配列を作るときは大カッ
562


--- picture_0010.png ---
コの中に要素数を指定しません。よって、コンバイルエラーとなります。
選択想Dは、int配列型の変数を宣言し、初期化子を使って配列のインスタン
スを生成しています。 配列のインスタンスが生成されてから、代入当算子で
変数に代入されるため、初期化子を使って配列のインスタンスの生成と要素
の初期化をしている時点では、まだ配列型変数には何も代入されていないこ
とになります。そのため、コンパイルエラーとなります。
選択皮Eは、Double配列型の変数を宣言し、初期化子を使ってインスタンス
の生成と要素の初期化を行っています。Double型は参照型であわるため、要素
の値はnullを許容します。1.0と浮動小数点数を与えた場合は、ポクシングに
よって自動的にDouble型に変換されます。よって、選択下Eは正しくコンバ
イルされます。

【第5章 : 商題7】
アクセス修衝子に関する問題です。
設問のsampleクラスにはheaderとvalueこという2つのフィールドが定義されて
います。headerにはアクセス修飾子が付いていないため、同じバッケージ内    第13章
であれば、ほかのクラスからアクセス可能です。
一方、valueのアクセス修飾子はprivateであるため、ほかのクラスからアク
 セスできません(選択肢B、C、D)。valueの値を取得するときには、publicで
 公開されているgetvalueメソッドを使うことになります。
選択受Aは、getValueの後ろにカッコ「()」 がないため、メソッドへのアク
セスではなくフィールドへのアクセスだと見なされます。sampleクラスには
getValueというフィールドは存在しないため、コンパイルエラーとなります。
なお、headerフィールドやgetvalueメソッドは、staticで倍人されたクラス変
数とクラスメソッドです。そのため、それぞれを利用するには「クラス名.フィー
ルド名]「クラス名. メソッド名] のように記述します。
以上のことから、選択肥Eが正解です。

【第6難 : 問題26】
代入演算子と演算子の優先順位に関する問題です。
設問のコードでは、 変数aとbを宣言し、 それぞれ10と20で初期化しています。
5行目が問題のポイントですが、右部から順に評価していきます。
まず、次の下誠の部分からです。変数asの値は10なので、5で割るとその結果
は2です。


--- picture_0011.png ---
団設問のコード5行目の演算①
intcsbtra/5i
そのため、次のような式になります。この式で次に評価されるのは下深の部
分です。
団 設畔のコード5行目の演算の
intcsbts2
これは「b - b 2] の加算代入演算子 「+ー」 での表記なので、20二2の結果
である22が変数bに代入されます。このタイミングで、変数aは10、変数bは
22になります。 最後に次の式が実行されるので、 変数<も22になります。
団 設財のコード5行目の演算
intc=bi
変数。は10、 変数pは22、そして変数=も22なので、合計は54となります。以
上のことから、 選択上8が正角です。
[昌3章 : 問題1
20. B                                       にPsie」
配列の要素のデフォルト価に関する再丁です。
プリミティブ型の配列の場合は、数なら0、 浮動小数点数なら0.0、 文字な
らYu0000、真個ならfalseがデフォルト値です。 参康型の場合は、nullがデフォ
ルト慎になります。
設問のコードのように、5つの可素を持つ配列インスタンスを生成し、量初と
最役の要素だけ何も入れない場合、配別にはnul、 AN "BK *CN nul(の順で
要素が入っています (正確にはStringなので参照が入っています)。
撤拓for文は、次に取り出すべきものがない場合は繰り返し処理を実行しませ
ん。 配列の最初の要系はnuですが、次に取り出すべきものがあります。 そ
のため、まずnulがコンソールに表示され、いてA、B、てが表示されます。
最後の要素もnulですが、そのあとに取り出すものがないため、nulをコンソー
ルに表示してから撤for六抜けます。以上のことから、沢股Bが正餅です。
[生計題5
564


--- picture_0012.png ---
21. A
ローカル変数とフィールドのアクセス方法の遅い(に関する半題です。
メソッド内で宣言したローカル変数にアクセスするには変数名を記述するだ
けですが、インスタンスのフィールドにアクセスするには参照.フィールド名|
と記述しなければいけません。
設問のコードでは、 testメソッドでフィールドの値を3に増やしています。
Tmanメソッドではsampleクラスのインスタンスを生成し、testメソッドを実
行した結果をローカル変数numで腕け取っています。この時点でローカル変
数numの値は3となっています。
その後、もう一度testメソッドを実行してフィールドの倍を3に増やしていま
すが、コンソールに出力しているのはローカル変数のnumが持っている値で
す。 もし、フィールドの値を出力するのであれば [snum」 のように記述し
なければいけません。 以上のことから、居所肝Aが正解です。
ED|
22. D
モジュールに関する問題です。                                      第13章
Java SEの基本的なAPlが含まれるモジュールは、java.baseモジュールです。
よって、 選択設Dが正解です。
送択股Aや6のようなモジュールは存在しません。 人所彼Cのjava seモジュー
ルはJava SEで湯朱されるAPIが含まれていますが、其太的なAPIではなく、
jeangパッケージは含まれていません。公式のAP ドキュメントでモジュー
ルの説明を参照すると、どのモジュール(にどのようなパッケージが含まれて
いるのかがわかります。
Uava Platform, Standard Edition & Java Development Kit バージョン11
AP仕様]
hps:7docs.oracle conviavasefjp/11/docsapVindex html
[第1音 :
23. でC                                            EEEE
ポリモーフィズムとアクセス人人L子によるフィールドの決定に関する問題
です。
設問のコードでは、Aクラスとクラスに同名のnumフィールドが定装されて
います。これらの違いはアクセス修秀子です。
ムクラスのnumはpubhicが付いているのでどこからでもアクセスできるのに対
して、5クラスのnumはアクセス修筋子が付いていない (デフォルト) ので


--- picture_0013.png ---
別バパッケージからはアクセスができません。
変数の型で扱われるフィールドとインスタンスの型で扱われるフィールドが
あり、これらの名前が同じ更合は、ポリモーフィズムによって、 変数の型で
峡言したフィールドが使われます。 そのため、mainメソッドでアクセスして
いるanumはAクラスに定基したnumフィールドの仁を参照することになりま
す。 ムクラスのnumフィールドはpublicなので別パッケージからもアクセス可
能です。よって、コンソールには10が表示されます。以上のことから、選所
股Cが正人巡です。
なお、次のように変数を8型に変更すると、Bクラスのnumフィールドは列バパッ
ケージからのアクセスができないため、Mainクラスでコンバイルエラーとな
ります。
団 到SXaの型をBに変更 (コンパイルエラー)
jackage ex23。
1mport eX23.a.届
3mmort ed23.b.B
puptic class Main (
public static void main(String[] args) (
Ba = new B0:
System.outprintln(amm):
)
)
【第7章 敵題15】
24. A                                            EEEE
オーバーライド時のアクセス修飾子に関する問題です。
スーパークラスに定義されたメソッドをサブクラスでオーバーライドすると
きのルールは次のとおりです。
シグニチャが同じであること
戻り仁型は同じ型か、サブクラス型であること
アクセス修子は同じか、より緩くすること
throwsで宣言する例外は、スローする例外と同じ型かサブクラス型である
こと
566


--- picture_0014.png ---
設問では、publicで宣言されてメソッドをオーバーライドすることになって
いるため、 オーバーライドしたメソッドもpubicでなければいけません。よっ
て、 選択役Aが正解です。

(第 : 病1】
クラスのアクセス修子に関する商題です。

4つあるアクセス修節子のうち、アクセス修飾子なしはバッケージ内からし
かアクセスできないことな表します。

設問のコードでは、ex25.aバッケージに民するsampleクラスを、e25.5バパッ
ケージに司するMainクラスが利用していますが、sampleクラスのアクセス修
侯子はpublicではありません。sampleクラスは、外部のバッケージからアク
セスできないクラスであるため、 このコードはコンバイルエラーとなります。
以上のことから、選択有が正解です。

信介 :商古6】
staticに関する問題です。                                     第13章
staticで倍向されたメソッドからは、staticで條師されたもの以外にはアクセ
スできません。 設問のコードではstaticなmainメソッドから、testメソッドを
呼び出していますが、これはstatcなメソッドからstatcなメソッドの呼び出し
のため表題ありません。しかし、testメソッド内ではstaticでないnumフィー
ルドをインクリメントしています。 そのため、testメソッドでnumをインク
リメントしている4行日でコンバイルエラーが発生します。 以上のことから、
師所陵が正如です。

第5問題5】
 stringクラスのメソッドに関する問題です。
java.lang-Stringクラスのメソッドは、インスタンスが保持する文字列を変
更しません。 設問のようにreplace (寺き換え) やsubstring (抽出) といっ
たメソッドは、内部の文字多を変更せずに新しい文字別をコピーし、その文
字列を変更したものを戻します。 そのため、次のように変更後の文字別を受
け取るための変数用意し、メソッドの結果を代入しなけれぼ、変更した結
果は壮りません。

次ページに読く


--- picture_0015.png ---
団 変更後の文字列を受け取る変数にメソッドの結果を代入
pubtic class Sampte {
publio static void main(String[] args)
String str = "beder
str = str.replace('c'。 ): でrmplhceの休をxmlE入
Str = Str.substring(2。4: でvbswingの給条をwwiR入
System.out.println(str):
)
}
設問のコードでは、replaceメソッドやsubstingメソッドを呼び出しています
が、その結果を受け取っていません。そのため、 変数srで参照されるsring
のインスタンスは変更されません。よって、 選択皮Bが正骨です。
[頃2 : 問題3、141
wiインタフェースのorEahメソッドに関する問政です。
java_util.ListインタフェースのforEachメソッドは、Consumer型のラムダ式
を受け取ります。Consumerは消作者という奄味で、その名のとおり細を受
け取り、その引散を消到して何かの負理をするためのインタフェースです。
衛択肢Aは、引区を受け取っていません。よって、 誤りです。
居択肢Bは、3|exを受け取り、コンソールに表示しています。 Consumer8の
利用方法であり、正しいラムダ式となります。よって、 正解です。
Corsumer思のラムダダ式では、3引牙を消窒するだけで戻り信を戻しません。 よっ
て、 戻り仁を戻している局所本Cは誤りです。 数を受け取り、戻り値を戻
すのはFunction型の役割です。
逢択肢Dは、lst型のままコレクションへの参照を渡していますが、forEachメ
ソッドが受け取る引数はConsumer型だけです。よって、誤りです。
[系8調 : 問題8、第9講: 半題18】
fnalで億師されたフィールドの初基化に関する問題です。
finalで公飼された変は定数として扱われ、一度設定した憶は変更すること
ができません。 設問のコードではsampleクラスのnumフィールドが定数とし
て訓言されていますが、初朋化されていません。そのため、コンストラクタ
で値を初因化する必要があります。
間          このsampleクラスには、オーバーロードされたコンストラクタが3つありま


--- picture_0016.png ---
す。3つのうち、 引数がある2つはnumフィールドの値を初期化していますが、
引数なしのコンストラクタではフィールドの値を初期化していません。よっ
て、9行目の引到なしのコンストラクタの定義でコンパイルエラーとなりま
す。以上のことから、選択肢Dが正解です。
【第6草 : 問題21】

 抽象メソッドの実装についての問題です。
インタフェースに定義される抽象メソッドは、量黙的にpublicで修知され
ます。これは、インタフェースとは外部に公開することを目的としている
ものだからです。そのためコンバイラは、設問のFunctionインタフェースの
processメソッドはpublicで修飾されていると解釈します。
設問のコードでは、Functionインタフェースを実現したsampleクラスを定義
しています。このメソッドは具旬クラスであるため、インタフェースに定
義された抽象メソッドの実装を提供する必要があります。Sampleクラスは
processメソッドを実装していますが、問征はにのメソッドのアクセス信飾子
がprotectedになっている点です。このようにインタフェースな実現したクラ
スで具象メソッドを旭供する場合は、アクセス修飾子を変更することはでき     第13章
ません。
これはクラスの継承でも同様で、スーパークラスのメソッドをオーバーライ
ドするときに、より厳しいアクセス修範子で修飾することはできません。イ
ンタフェースを実現したクラスや、何らかのクラスを継承したサブクラスで
メソッドを実装、もしくはオーバーライドするときは、より厳しいアクセス
修餅子は使えないことを党えておきましょう。以上のことから、選択肢Cが
正角です。

【第7章 : 問題9、11】
java.utiLMapインタフェースに関する問題です。
Mapインタフェースは、キーとバリューの組み合わせで管理するコレクショ
ンです。Mapはすべてのキーだけを取り出したり、すべてのバリューだけを
取り出したりすることができます。キーを取り出すにはkeySetメソッドを、
バリューを取り出すにはvaluesメソッドを使います。keySetメソッドはjava
utilL.Set型、yaluesメソッドはjava.util.Collection型のオブジェクトへの参照を戻
します。以上のことから、選所肢Aが正丁です。
選択肢Bは引数の指定でデータ型を記述しているため、メソッド呼び出しの


--- picture_0017.png ---
構文になっていません。また、選択肢Cのようなmapフィールドはスーパー
 クラスには存在しません。
IMapのforEachメソッドを使って繰り返し処理をすることは可能です。選択
肢Dのラムダ式では引数にkとvを受け取ります。これらのデータ型は、Map
が扱うキーとパリューのデータ型になるため、どちらもString型になります。
しかし、sString型を受け取るsetメソッドはAクラスにもBクラスにも定義され
ていないためコンバパイルエラーとなります。

【第9章 : 陸題19】
インタフェースの特徴に関する問題です。
Javaではクラスの多重継承はできませんが、インタフェースの多重継承は可
能です。よって、有選択肢Aは誤りです。
インタフェースの主な目的は型情報を提供することですが、java SE 8からデ
フォルトメソッドが使えるようになったため実装を持つことができます。そ
のため、スーバーインタフェースに定装されている抽避メソッドを、サブイ
ンタフェースのデフォルトメソッドでオーバーライドすることは可能です。
よって、選択肢は正しい説明です。
同じ型かサブクラスであれば、オーバーライドするメソッドの戻り値型を変
更することができます。これを「共変戻り値] といいます。 共変戻り値はイ
ンタフェースでも使えるため、戻り値型を変更できないとした選択肢Cは誤
りです。
インタフェースを継承したサブインタフェースの定義では、スーパーインタ
フェースの負象メソッドを実装しなければならないわけではありません。イ
ンタフェースを実装した抽象クラスと同じで、最終的にすべての実装を持つ
べきなのは具象クラスです。よって、選択肢Dは誤りです。

【第7草 : 問題3、4】
オーバーロードに関する問題です。
設問のコードのsampleクラスでは、オーバーロードされた3つのtestメソッド
が定義されています。Mainクラスの3行目ではsampleのインスタンスを作り、
in配列型の引数を渡してtestメソッドを呼び出しています。
オーバーロードされた複数のメソッドと完全一致しない引数を渡した場合、
そのメソッドを呼び出しているコードがコンバイラにより型変換され、対応

5              するメソッドを呼び出すように最適化されます。


--- picture_0018.png ---
配列はObjectクラスのサブクラスであるため、配列をObject型こして受け取
るオーバーロードで処理することは可能です (選択肢C)。
一方、Object型の配列は、プリミティブ型の配列とは互換性がありません。
Object型(参照) の集合を扱う配列と、プリミティブ型 (値) の集合を扱う
配列は、 そもそも扱っている集合の種類に互換性がないからです (選択肢4)。
選択彼6のようにプリミティブ型の集合同士であれば互換性はありますが、 32
ビットの数値 (int型) を64ビットの数伯 (long型) に型変換 (32ピット分の
0を追加する) する負理が必要になります。 配列をObject型として扱う場合に
は、このような短理は行われないため、どちらが近い型を扱っているかとい
う観点では、選択肢Bより選択肢C〇のほうがより近い型を扱っていることにな
ります。

【第6凍 : 問題16、17】

34. A                                                                                        EE
2次元配列と拡張for文に関する問是です。
設問のコードでは、 1次元目に2つ、 2次元目に4つの要素を持つ2次元配列のイ
ンスタンスを生成しています。このタイミングで、次の記のようにすでに3
つの配列のインスタンスが生成されています。
第13章
【設問の配列のイメージ①】
1次元目の配列インスタンス
lm
この2次元琵列に、 1次元日の1つ日の要素として4つの要素と2つの要素を持つ
1次元配列を2つ生成し、要素を置き換えています。そのため、配列のイメー
ジは次の図のとおりとなります。
【設問の配列のイメージ⑧】
叶


--- picture_0019.png ---
設問の二重ループは外側、内側とも拡張for文を使っています。 拡張for文は、
配列やコレクションから順番に要素を取り出し、取り出すべき要素がなくな
るまで処理を繰り返します。 外側の拡張for文では、2次元配列の1次元目を拓
り返して取り出し、int配列型の委数aに代入しています。 内側の拡張for文では、
変数aで参照可能な、元は2次元目だった配列から1つずつ要素を取り出して、
コンソールに表示していきます。上図からわかるとおり、1つづ目の2次元目の
配列には1、2、3、4という値が入っており、2つ目の2次元目の配列には1、2とい
う値が入っているため、「1234] と「12]」 が表示されます。よって、和選択肢
Aが正餅です。
2次元配列を扱うときは、2次元目の配列の要素数が揃っていないといけない
ように思いがちですが、設問のように非対称であっても則題はないため、選
択肢Dのようにコンパイルエラーとなることはありません。

【第5章 : 問題8】
Javaの特徴に関する問益です。
元々、ソースコードは人間が読おむためのコードで、コンピュータが実行する
には適していません。 そこで、コンバイルによって実行しやすい形に翻訳し、
最適化しておくのです。コンパイルでは、jVMが読み込んで処理できるよう
にコードが質訳されます。言い換えれば、JvMはあらかじめ決められた形式
でしかコードを読み込めません。そのため、別の形式に入訳された (コンバ
イルされた) 実行可能ファイルを読み込んで実行することはできません (選
択肢A)。
コンパイラはコンパイルする際に、コードを実行する対象のプラットフォー
ムを考歳しません。あくまでも、コンバイラはJ」yMが読み込める形式に可訳
するだけです。コンパイラは、実行対象のプラットフォームを考慮しないた
め、実行環境で動作できるかどうかのテストは行いません。 各プラットフォー
ムで実行できる形式にコードを策訳するのはJVMの役割でちって、コンバパイ
ラの役割ではないことに注意してください (選択肢B、C)。
ほかのプログラミング言語では、コンバイルしたコードを1つのファイル
にまとめて、 実行時にメモリにすべて読み込んでしまうものもありますが、
Javaは必要に応じて、必要なクラスファイルを読み込みます。 以上のことから、
選択肢Dが正解です。

572


--- picture_0020.png ---
36. D                                       EEE3
ラムダ寺の宣言に関する周還です。
ラムダ式は、引数宮言のデータ型を省略することができます。たとえは設問
のコードは、次のようなコードに記述されている引招言のデータ型を作
した形になっています。
団 3 数宣言のデータ型を記述しているコード
immort jaa.uti1.fnmction.Consumeri
mptic class Main [
pebtic static void main(Stringl] ares) 【
ina String val "ello。 Iambda": で変了が李している
ConsumerKString) fune = (SLring vaU) Srstem.out.primttntval):
me.accept("Hello。 Java'): # 下手している
}
}
このコードからわかるとおり、ローカル座数とラムダ式で宮言している充数 第13意
 名Yalが還客しといます。そのため、このコードはコンバイルエラーとなりま
す。 よって、 選択肢Dが正解です。
【第8斉 : 届題1】
37. C                                       にP52e |
初期されていないローカル変数の利用に関する問題です。
初期人されていないローカル変数を参照すると、コンバイルエラーになりま
す。 設問のコードでは、mainメソッドでString型変数strを宮言していますが、
この会致は初期化されていません。しかし、tcstメソッドを呼び出す際にこ
の初央化されていない変数strを参照して慎を渡そうとしているため、この
コードはコンバイルエラーとなります。よって、 選択段てが正解です。
なお、ローカル変数ではなく、フィールドの場合はインスタンス生成時にデ
フォルト値で初期化されるため、明示的に初期化しなくても参照することが
できます。
[第5間: 問題9


--- picture_0021.png ---
38. E
洒算子の居先順位に隣する問題です。数学の計算順と同じように考えて解き
ましょう。
設問の計算式は、まずカッコ 「()」で括られた掛け算から実行されます。 実
行後の式は次のとおりです。

還 設問のコード3行目実行後の式①

int result = 30 - 12 / 10・

数学と同様、加人算や減著よりも除條 (市り算) が張完されます。数値リテラ
ルはデフォルトでint型として扱われるため、 1210の結果は、小数点以下が
切D持てられて1になります。
団設のコード3行目実行後の式の

jmt resutt = 30-11

加算と減算は同じ優先順位なので、そのまま計算すると変数resuiには30が代
入されます。以上のことから、 各所了Eが正解です。

[3 :半呈

39. D
繰り返しの制御に関する問題です。
continueは、繰り返し各理の途中に現れると、それ以降の処理をスキップし
ます。 そのため、設問のコードでcontinueの次の行に記述されている変数cnt
のインクリメントは、 実行できまないコードです。このような実行できない到
達不可能なコードがあった場合は、コンバイラエラーになります。 よって、
選択股Dが正解です。

[4章 : 問題15]

40. A                                       |・P52e |
注算の順番とインクリメント、 文字人連結に関する敵是です。
インクリメント演算子は前置と後陸で和作が異なります。 前填すると値を1
増やしてから変数の仁を参照し、後直すると着やす前の人のコピーを戻して
から変数の値を増やします。

574


--- picture_0022.png ---
設問のコードでは、まず 「num+++ num という式を実行します。 この式は、
変更前のnumの値 (0) をコピーして戻してから、計数numの値を{増やし (1)、
コピーした仁と変吉numの人慎(1) を吉偶するという意味になりますず。よって、
この式の結果は「1] となります。この時点で、計算式は次のようになります。
EDUEECTEST1
数倍と文字列を+湯算子で演算すると、数字 (文字列) に変換されて文字列
同二の連結になります。字列轄結すると、計算式は次のようになります。
EESTTEST
-当算子による連結は、 演算子の左右両方のオペベランドが数司や文字列でな
ければ行われません。 上記の計算式は文字列とインクリメント注算の加算に
なっているため、先にインクリメント注算を実行します。このインクリメン
ト洒算子は前置されているので、値を1増やして2に変更します。これにより、
 次のような計式になります。
第13章
EIC 2
上記は文字列と数値の連結ですので、 数全数字に変換され、最終的な演算
杜果は [1.22] となります。 以上のことから、選択段Aが正館です。
[第 : 娠本4)
41. A                                       EE
拡張for文とiX、contnue、brckを組み合わせた隊頼です。
設財のコードでは、AーEよでの文字を要素として持つ配別から1つずつ可素
を取り出しながら、療り返し尋理を実行しています。線り返し処理の導中で、
条件に合致したときにcontinueやbreakが実行されます。
1つ目のifxでは、 変数strの値が rp' のときに実行され、その後ろの行のコン
ソールへの出力をスキップしてしまいます。そのため、8という文字がコン
ソールに出力されることはありません。
また、2つ目のi文では、変数rの値が *C のときに実行され、breakによって
ループを抜けてしまいます。そのため、てよりも後ろのpとEがコンソールに
表示されることはありません。


--- picture_0023.png ---
拡張for文は、 配列の先頭から順に要素を取り出して処理していきます。その
ため、最初に表示される文字は「A] です。「B」は前述のとおり表示されません。
次の 「C」 が表示されたあと、breakによって線り返しが終了するため、コンソー
ルに表示されるのは「Al と「C] の2文字です。以上のことから、 選択肢Aが
正解です。
【第4章 : 習題11、14、15】
tyrwith-resources構文に関する問題です。
try-with-resourcesは、例外が発生したときに自動的にリソースのcloseメ
ソッドを呼び出し、リゾースを解版する便利な構文です。例外が発生した場
合、trwith-resourcesでは次の順番で処理されます。
① closeメソッドによるリソース乏故の処理
⑧ catchプロックによる例外処理
③ finalyプロックによる事後処理
例欠処理よりも先にcloseメソッドによるリソースの解放が行われる点に注意
してください。
設問では、java.lang.AutoCloseableインタフェースを実装したsampleクラスを
リソースとして定義しています。このリソースを使い終わるとcloseメソッド
が呼び出され、コンソールに「c| と表示されます。 設問のMainクラスのtry
ブロック 35行目) ではすぐに例外をスローしているので、まずリソース
のクローズが行われ、コンソールに 「C」 が表示されます。その後、catchプロッ
ク、そしてfinallyプロックと続き、コンソールには「A」 「B]」 と順に表示され
ます。以上のことから、選択財てが正蟹です。
【第10章 : 問題10】
モジュールシステムに関する問題です。
モジュールの設定ファイルであるmodule-info.javaは、モジュールのルート
ディレクトリに配置します (選択肢A)。
モジュールの設定ファイルに定義するexportsでは、そのモジュールが持つ
パッケージのうち、公開するパッケージな富言します。 java.baseモジュール
はjavaの基本的なクラス群がまとめられたモジュールであり、どのモジュー
ルにも自動的に組み込まれます。そのため、exportsで宣言する必要はありま
せん (選択股B)。
請            利用するモジュールは、module-info.java内でrequiresを使って宣言します。


--- picture_0024.png ---
王言されていないモジュールを利用することはできません (届択下C)。
何も利用せず、休公開しないモジュールであれば、module-info.jawa内を空
にすることはできます (避所<
モジュールなを実行するときは、モジュールに対してクラスパスが通ります。
 そのため、モジュールに含まれるプログラムは、モジュール内のディレクト
りにはアクセス避能です (選択肛D)。
(第1草 :呈3
コンストラクタチェインに関する敵題です。
挫束関係にあるとき、サブクラスよりも先にスーパークラスのコンストラク
タが実行されます。 設問のコードでは、Aクラスを迷基した8クラス、そのB
クラスを妊承したCクラスを定諸しています。そのため、cCクラスのインスタ
ンスを生成したときのコンストラクタはA、8、Cの順に突行されます。よって、
選択段Aが正解です。
何らかのクラスを失承したクラスを十差するとき、次のようにコンストラク
タの先頭行にスーパークラスのコンストラクタ呼び出しのコードがコンバイ
ラによって自動的に追加されることを党えておきましょう。               第13章
較 スーパークラスのコンストラクタ呼び出し
class』(
mbtic AO) (
uper():。 でobjtウラスのコンストラクタ時出し|
System_out.print("A):
}
}
class B extends At
mubtic 8() (
suDer(): でAクラズのコンメトラクタ時出し
System.ut.print("B'):
}
}
class CextendsBt
mbtic CO (
suDer()。 <クラスのコンストラクタ呼OHし
System.out.print("C"):
H
}
(第7 : 則21】


--- picture_0025.png ---
45. B、D、E                         にssi |

抽名クラスに関する問屋です。
抽旬クラスには、 実装を持たない抽象メソッドと、実装を持つ具象メソッド
の可方を定義できます。 抽象メソッドを定義するときには、sabstractで公休
しなくてはいけない点を忘れないようにしましょう。
各択股Aは、メソッドの宜言細加を示す中カッコ 「() 」 が記述されていません。
つまり、 実装を持たない操メソッドとして定義していますが、abstractで修
秀されていません。よって、コンパイルエラーとなります。
選択陸は、 実装を扶つ具象メソッドです。中カッコ内に実務したい如理が
記述されており、abstractで憶分されてもいません。よって、正しいコードです。
選択有Cは、実装を持つ具華メソッドです。しかし、abstractで公休されてい
るため、抽祭メソッドとして争札されます。抽祭メソッドは、 実装を持つこ
とができないため、このコードはコンバイルエラーとなります。よって、 誤
りです。
選択上Dは、抽旬メソッドです。abstractで修似されており、かつメソッドの
半生団を示す中カッコが和省時されています。よって、正しいコードです。
選択岐Eは、具灸メソッドです。中カッコ内に実施したい処理が記述されて
おり、ahstactで修記されてもいません。よって、正しいコードです。

【第7章 : 半題81

46. C                                       にPss1

jaa」ang.Matnクラスのメソッドに関する問題です。
Mathクラスのroundメソッドは、小数点以下の仁な四挫五入して丸めるため
のメソッドです。powメソッドは、第1引数の値を第2引数の値で困乗するた
めのメソッドです。たとえば、2のぅ系を計算するには、「Math pow2. 3)] と
記述します。
設問のコードでは、powメソッドの結果をroundメソッドに渡しています。
powメソッドでは、3.1の2乗を計算しているので、結果は9.61となります。こ
の慎を小数点以下で四描五入した結果は10となります。以上のことから、選
択財Cが正解です。

【第9章 : 問題1

578


--- picture_0026.png ---
47. A                                       にPss2 |
オーバーライドに関する問題です。
スーパークラスに定義されたメソッドをサプクラスでオーバーライドすると
きのルールは次のとおりです。
・シグニチャが同じであること
・ 戻り値型は同じ型か、サブクラス型であること
・アクセス修飾子は同じか、より緩くすること
・throwsで宣言する例外は、スローする例外と同じ型かサブクラス型である
ブー
選択彼Aよは、シグニチャは同じですが戻り値型が異なります。しかし、
Integer型はNumber型のサブクラスであるため、オーバーライドしたメゾソッド
の戻り値型として使うことができます。よって、正解です。
選択肢8は、引数なしのメソッドをオーバーライドしているにもかかわらず、
jnt型の引数を受け取っています。シグニチャが異なるため、オーバーライド
 ではなく、オーバーロードだと解収されます。よって、誤りです。
第13章
選択肢Cは、戻り値型をNumberからvoidにしているため、オーバーライドに
はなりません。スーバークラスのメソッドでは戻り値を戻していますが、 実
際に動作するインスタンスのメソッドでは戻り値を戻さないため、コンバイ
ルエラーになります。よって、誤りです。 ポリモーフィズムでサブクラス
 のインスタンスをスーパークラス型で扱ったときに、オーバーライドしたメ
ソッドがスーバークラスと互換性がなければ動作できないことを理解しま
しょう。
選択肢Dは、スーパークラスの定義には記述していない例外のスローを宣言
しています。有選択肢Cと同様、ポリモーフィズムを使ってスーパークラス型
で扱うのであれば例外処理を行う必要はありませんが、 実際に動作するイン
スタンスでは例外処理を強制する定義になっています。よって、 誤りです。
【第7草 : 周題1】
48. D、E                                    EEEEE
コンバイルと実行コマンドに関する問題です。
javacコマンドとjavaコマンドに関しては、次の2点に注意しましょう。
コンバイルするときのjavacコマンドの引数には、拡張子のjavaまで含む
ソースファイル名を記述する


--- picture_0027.png ---
実行するときのjavaコマンドの引数には、クラスファイルのファイル名で
はなく完人修飾クラス名を記述する
上記のとおり、 選択役Dは、 手順、引数ともに正しいコマンドです。
選択肢Eは、javaコマンドのソースファイルモードで実行しています。ソース
ファイルモードは、ソースファイルをコンバイルし、クラスファイルに相当
するバイトコードをメモリ上に生成して、そのクラスのバイトコードを実行
できるようにする仕組みです。
選択肢Aは、javaコマンドに完全者術クラス名ではなく、クラスファイル名を
散に渡しています。 よって、話りです。
選択8は、javaecコマンドでコンバイルし、jaqコマンドで実行する手順は前
違っていませんが、 選択肢Aと同様にクラスファイル名をjavaコマンドに涙し
ています。よって、 誤りです。
選択肢qは、javaコマンドとしては正しいですが、コンバイルしていないため,
クラスファイルが存在はず実行できません。よって、課りです。
【第1章 : 問題6.7】
変数のスコープに関する問題です。
変数には、 メソッド内で家言するローカル変数と、クラス内で末言するフィー
ルドの2種類があります。同じ名前の変数は宣言できませんが、 種類が実な
れば宮言できます。 設問のコードでは、 2行日でフィールドとして。と5な宣言
していますが、同時にmainメソッドのローカル半数sとbな宣言しています。
このように同名の変束を宮言した星合、thisを使わない限り、ローカル変数
が候先されます。そのため、mainメソッドの最後の行でコンソールに出力し
ているのは、フィールドの値ではなく、ローカル変数の値です。
以上のことから、選択肢Cが正解です。
[生間 :半是181
オーバーライド時のアクセス候子に関する問題です。
スーパークラスに定義されているメソッドをオーバーライドするとき、アク
セス倍飼子を緩くすることはできますが、 衣しくすることはできません。 設
問のコードは、Sampleクラスに定義されているdoProcessメソッドをオーバー
ライドするとき、protectedをデフォルトに低しく変更しているためコンバイ
ルエラーが発生しています。
了           このようなコンパイルエラーを角消するには、アクセス修導子をprotectedに


--- picture_0028.png ---
戻すか、査く (つまりpublicに) します。 以上のことから、 選択詳CとDが正
解です。
第7 :病是1】

51. C                                       にPss4 |

ダイヤモンド注算子を使ったジェネリクスに関する問題です。

ダイヤモンド演算子 「く>」 は、ジェネリクスで使う型パラメータの型推論を

行います。ダイヤモンド洒算子は代入される容数を参照し、弄推論します。

推答できなかった場合には、自動的にObjer型が利用されます。

設問のコードでは、varを便ったローカル変数の型推論と、ダイヤモンド注
